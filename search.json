[{"title":"深入理解java泛型","path":"/2024/03/27/深入理解java泛型/","content":"认识java的泛型机制泛型机制（Generics）是一种编程语言特性。允许在编写代码时使用参数化类型。它允许开发者在设计类、接口和方法时使用类型参数，这些类型参数可以在使用时被实际的类型替换。泛型机制的主要目的是增加代码的灵活性、可重用性和类型安全性。 我们通过一个简单的例子认识java的泛型已经感受一下泛型的好处： 假设我们需要实现一个加法功能，支持多种数据类型进行相加。 我们可以使用重载写多个add方法： 1234567891011121314private static int add(int a, int b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static float add(float a, float b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static double add(double a, double b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125; 这样做每种类型都需要重载一个add方法；而通过泛型，我们可以复用为一个方法： 12345//这里定义了一个泛型方法，返回值类型为double,方法接收的参数类型为Number类型及其子类。private static &lt;T extends Number&gt; double add(T a, T b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue();&#125; 再看这个例子，向一个集合animals中添加3个Dog对象： 123456789101112131415161718192021222324252627class Dog &#123; private String name; Dog()&#123;&#125; Dog(String name) &#123; this.name = name; &#125;&#125;class Cat &#123; private String name; Cat()&#123;&#125; Cat(String name) &#123; this.name = name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; //传统写法 List dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //手动类型转换 Dog dog1 = (Dog)dogs.get(0); &#125;&#125; 这样写存在什么问题呢？ 需要手动进行类型转换：因为我们在声明List的时候并没有指定集合当中元素的类型，ArrayList只是维护了一个Object引用的数组。我们接收这个对象就需要进行一次类型装换：Dog dog1 = (Dog)dogs.get(0); 进行强制类型转换效率较低，并且可能会抛出类转换异常ClassCastException。而这个异常我们无法在编译中发现，只能在运行时才能发现，存在安全隐患。 不能对集合中元素的类型进行约束：在我们的需求是往dogs中添加Dog对象。但是如果我向集合中添加其他类型的元素编译时却不会有任何错误提示：dogs.add(new Cat(&quot;阿猫&quot;)) ，而是在运行时我们取到这个Cat类型的元素并使用（Dog）进行转换时抛出来ClassCastException。 使用泛型解决： 12345678910public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //取元素的时候不需要手动类型转换 Dog dog1 = dogs.get(0); //插入不符合预期的类型会报错 //dogs.add(new Cat(&quot;小猫老弟&quot;)); The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)&#125; 这显然不是我们所期望的，如果程序有潜在的错误，我们更期望在编译时被告知错误，而不是在运行时报异常。 通过这两个例子，我们可以很好理解为什么使用泛型能增强代码的复用性和类型安全性。接下来我们进一步认识java当中泛型的使用方式。 为什么需要泛型？引入之前存在什么问题？使用泛型有什么好处？在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设置为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法将会更具有通用性。此外，如果将方法参数声明为接口，将会更加灵活。 在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型的语法？怎么使用泛型？泛型的原理是怎么样的？实现的细节？ 理解java的伪泛型。理解类型擦除","tags":["java-se"]},{"title":"Hello World","path":"/2024/03/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"Welcome to my bolg!"}]