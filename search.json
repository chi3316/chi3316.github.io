[{"title":"何为心外无物","path":"/2024/06/09/我的人生意义/","content":"我是为何目的来到这个世界？为何目的而活？ 先生游南镇，一友指岩中花树问曰：“天下无心外之物：如此花树，在深山中自开自落，于我心亦何相关？”先生曰：“你未看此花时，此花与汝心同归于寂：你来看此花时，则此花颜色一时明白起来：便知此花不在你的心外。” 意思大致是说：世界万物的意义和存在都依赖于人的心。花树在深山中自开自落，如果没有人的心去感知，它就如同不存在一般。只有当人们用心去看它时，它才具有了意义和存在。 我要如何找到自己的价值存在呢？什么事物能作为我的价值追求和精神支撑呢？ 我现在觉得自己轻飘飘的，找不到自己生命中终极的意义。这样的状态会经常使我陷入迷茫与内耗之中。 我时常问我自己是为了什么而努力生活？为了什么而奋斗？ 心中给出的答案好像只能是为了我的家人，为了给他们幸福的生活。 如果说屈原的价值存在是他的国家，他所追求的是国家的强盛和人民的福祉。当他被小人陷害，流放异国他乡，看着奸臣残害百姓，谋逆国家时，他会为此痛恨不已。当楚国被灭亡时，他可以为此殉国，因为自己的精神支柱已经不存在了，人活着已经没有任何的意义。 现在的我很想找到这样一个人生意义与精神支撑。我所做的一切应该都是为了这个价值追求。 我想了解王阳明的心学，西方的存在主义哲学也是因为我觉得他们能帮我找到生命的意义。 2024&#x2F;6&#x2F;16： 我找到了我存在的意义，我所做的一切是为了这两件事情： 一是为了我的家庭，二是在于修身。"},{"title":"计算机网络：Top-Down","path":"/2024/06/07/计算机网络/","content":"期末计算机网络知识复习总结 1. 计算机网络基本概念 Q：什么是计算机网络？ 计算机网络是由多个计算机系统及其他硬件设备通过通信链路互联而成的系统，旨在共享资源、数据和信息。网络中的计算机和设备通过协议（如TCP&#x2F;IP）进行通信，确保数据在不同设备之间可靠传输。计算机网络可以按规模、连接方式和功能进行分类，如局域网（LAN）、广域网（WAN）和互联网 基本组成部分 终端设备：计算机、服务器、智能手机、平板电脑等，用于发送和接收数据。 网络设备：路由器、交换机、集线器、网关等，用于数据传输和管理。 通信介质：有线（如以太网电缆、光纤）或无线（如Wi-Fi、蓝牙）介质，用于连接设备。 协议：一组规则和标准，如TCP&#x2F;IP、HTTP、FTP，用于确保设备间通信的正确性和有效性。 网络的类型 局域网（LAN）：覆盖小范围（如办公室、家庭）的网络，传输速率高，延迟低。常用的技术有以太网、Wi-Fi。 城域网（MAN）：覆盖一个城市或多个建筑的网络，规模和传输距离介于LAN和WAN之间。 广域网（WAN）：覆盖大范围（如国家、洲际）的网络，传输距离远，速率相对较低。互联网就是最大的WAN。 个人局域网（PAN）：覆盖个人使用范围的网络，如蓝牙、红外连接 计算机网络的应用 互联网：全球最大的计算机网络，提供信息检索、电子邮件、电子商务、社交网络等服务。 企业网络：支持企业内部通信和资源共享，提高办公效率和业务协同。 校园网：提供学校内部教学、科研和管理的网络环境。 家庭网络：连接家庭设备，实现互联网接入、家庭娱乐和智能家居控制 Q：网络核心、网络边缘的概念？ 网络核心（Network Core）是网络的中心部分，负责高速传输和交换数据包，确保数据能够在不同的网络边缘之间高效传递。核心网络通常由高性能路由器和交换机组成，提供主干传输和数据中继功能。 网络边缘（Network Edge）指的是网络中用户和设备直接接入的部分，包括终端设备、接入网络和边缘设备。它是网络中的第一跳，用户通过这里访问网络服务。 Q：网络边缘是如何接入网络核心的？&#x3D;&gt; 下面详细介绍了。 Q：现在使用的internet协议栈有几层？&#x3D;&gt; 5层 相关术语： 主机(host)（端系统，end system）：连接到网络的设备 通信链路(communication link) 分组交换机(packet switch) 分类：路由器(router)、链路层交换机(link-layer-switch) 因特网服务提供商(Internet sevice provider, ISP) TCP(transmission control protocol) IP(internet protocol) ISPs (Internet Service Providers) 因特网标准(internet standard)：由因特网工程任务组(internet engineering task force, IETF)研发。其标准文档称为请求文档(request for comment, RFC) 协议(Protocol)：定义了两个或多个通信实体之间交换的报文格式和次序，以及报文发送和&#x2F;或接受一条报文或其 他事件所采用的动作。 网络接入（Access Networks）：网络边缘接入网络核心 DSL(Digital Subscriber Line, 数字用户线) HFC( hybrid fiber coax) FTTH(Fiber To The Home，光纤到户) 拨号调制解调器：传输速率低（56 kbps），专用带宽。HFC：传输速率高（10 Mbps 到 1 Gbps 下行），共享带宽。DSL：传输速率中等（1.5 Mbps 到 100 Mbps 下行），专用带宽，受距离影响。FTTH：传输速率非常高（100 Mbps 到 10 Gbps），大多数情况下为专用带宽或部分共享，但实际体验非常高。 以太网 最流行 WIFI 广域无线网 : 5G、LTE等等。 物理媒体： 双绞铜线(Twisted-Pair Copper Wire) 同轴电缆(Coaxial Cable) 光纤(Fiber Optics) 陆地无线通信道(Terrestrial Radio Channels) 卫星无线电信道(Satellite Radio Channels) 网络协议栈： 目前因特网的协议栈为5层，但是国际标准化化组织(ISO)提出的使七层，称之为开放系统互连模型 (Open Systems Interconnection model, OSI model) 从上到下分别是： 应用层 (Application) 服务：网络应用以及它们的应用协议存留的地方 协议例子：HTTP, SMTP, FTP, DNS, P2P, Telnet 分组： 报文(message) 运输层 (Transport) （向上层）提供的服务：应用程序之间传送应用层报文 协议（实现机制）：TCP、UDP 分组：报文段 (segment) 网络层 (Network) （向上层）提供的服务：将分组从一台主机移动到另一台主机 协议（实现机制）：IP 分组：数据报 (datagram) 链路层 (Link) （向上层）提供的服务：将分组从一个节点(主机或分组交换机)移动到下一个节点 协议（实现机制）： 取决于该链路特定链路层协议 分组：帧(frame) 物理层 (physical) （向上层）提供的服务：将帧的一个一个比特从一个节点移动到下一个节点 协议（实现机制）：与实际的传输媒体有关 2. 应用层3. 传输层3.1 传输层的职责概述及其为上层提供的服务传输层负责为运行在不同主机上的应用进程提供逻辑通信，传输层的协议运行在端系统。大致的工作流程： 发送方：从应用层（主机上的应用进程）接收message，将其封装成segment ，利用网络层将数据发出。 接收方：从网络层接收数据，将segment重组成messaage，交给应用进程。 传输层是为不同主机的进程提供逻辑通信，是要依赖于下面的网络层（提供主机间的通信），由网络层找到目标主机，传输层找到目标端口，再找到对应的应用进程。传输层可以在网络层提供的服务之上进行增强，比如可靠性，顺序性，安全性等。 Internet传输层的协议包括TCP（可靠、保序）和UDP（不可靠、不保序）。 3.2 传输层的多路复用与解复用 Q：什么是传输层的多路复用与解复用？为什么需要？ 一个传输层实体会从上层接收到来自多个应用进程的message , 这些message共享这一个传输层实体，在接收方也一样。所以需要在发送方和接收方将这些message区分开，使不同的message能正确交给对应的进程。 Q：传输层是怎么实现的？ 通过在接收方将应用层传下来的message进行封装，加一些头部信息来标识，做到多路复用。在接收方根据不同的标识区分不同的报文，实现解复用。 Q：UDP和TCP在接收端解复用是不一样的，具体的区别是什么？为什么会有这样的区别？ 具体区别在于UDP解复用的时候是根据报文段的目标主机号和目标端口号定位sockte，而TCP则需要源主机，目标主机，源端口和目标端口四个字段来定位socket。产生这样区别的原因在于UDP和TCP创建socket时的所需的字段不同，而究其根本是因为TCP是面向连接的，而UDP不是。UDP不需要维护源主机到目标主机的连接信息，相当于使用UDP是只传过去就完事了，所以UDP socket不需要保留源主机号这一字段。而TCP面向连接需要握手，重传等等，是需要多次用到源主机号的信息的。 概念 发送方会从多个套接字（socket）接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装(该头部信息用于以后的解复用)。 接收方根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)。 UDP的多路解复用 假设主机A和主机B进行通信，A是发送方，B是接收方： 双方创建在各自的Socket。 A将message交给传输层，传输层将meaasge封装成segment，利用网络层发送给B主机。 B收到UDP segment之后，检查报文段的目标端口号，用该端口号将报文段定位给套接字。 在接收端，UDP套接字用二元组标识(目标IP地址、目标端口号)。如果两个不同源IP地址&#x2F;源端 口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字。 TCP的多路解复用 假设客户端C和服务器S： 服务器S建立起监听socket守候在80端口，等待客户端连接。C创建socket连接到服务器。 C将message交给传输层，传输层将meaasge封装成segment，利用网络层发送给服务器S。 服务器收到之后，会根据TCP segment的源主机，目标主机，源端口和目标端口来定位socket。 服务器能够在一个TCP 端口上同时支持多个 TCP套接字：每个套接字由其四元组标识（有不同的源IP和源 PORT） 在这种场景下，虽然这些socket共享一个端口，但是内核中有各自的标识。 在多线程的服务器中，会将不同的socket交给同一个进程中的不同线程进行处理。而对于单线程的服务器，书里写的是一个socket对应一个进程，也就是守候在80号端口的进程创建多个进程，将不同的socket交给他们处理。但是这样效率很低啊，有些连接不活跃，也浪费了资源，后面查阅相关资料，并不会这么做，而是会有I&#x2F;O调度模型，而是由一个进程来轮询这些连接，监听他们的状态并做出不同的处理。对于多线程的服务器也会使用线程池的机制来处理多个客户端连接。 3.3 无连接传输UDPUDP提供的是不可靠，不保序的传输，并没有在网络层提供的best effort的服务之上做太多的增强。如果要在UDP之上做可靠性传输，则需要应用层自己增加可靠性。 那为什么要存在UDP呢？ 不建立连接，传输速度快，实时性好（连接会增加延时 ） 简单：在发送端和接收端没 有连接状态 报文段的头部很小(开销小) UDP segment： UDP报文段由20字节的固定头部 + 可变长度的数据报文组成。 校验和(check sum)：检测在被传输报文段中的差错(如比特反转) 发送方： 将报文段的内容视为16 比特的整数，然后把这些16bits的整数相加（做1的补运算，进位回滚）得到校验和。再将校验和放在 UDP的校验和字段 接收方：收到数据之后进行一样的操作，进行16bits整数加法，再将计算值与检验和字段比较，不一致说明出错了，丢掉这个数据包，但是不会让发送方重传（TCP会有重传机制，UDP是没有的，丢了就丢了，它不保障）。 计算值与校验值不同：一定出错 计算值与校验值相同：也可能出错（残存错误） 了解：UDP的check sum如何生成 ？ UDP（User Datagram Protocol）的校验和字段用于确保数据在传输过程中没有发生错误。它覆盖UDP伪首部、UDP首部和数据部分。 UDP校验和计算步骤 构建伪首部： 伪首部不是真正的UDP报文的一部分，但在计算校验和时需要包含进来。伪首部包含以下字段： 源IP地址（32位） 目标IP地址（32位） 保留字段（8位，设为0） 协议号（8位，UDP为17） UDP长度字段（16位） 将伪首部、UDP首部和数据部分拼接： 把伪首部、UDP首部和数据部分拼接成一个连续的字节流。 将字节流划分为16位字（两个字节）： 如果总长度不是偶数，填充一个字节的0。 逐个相加所有16位字： 使用二进制补码求和。如果有进位，则将进位加到结果的最低有效位。 对和取反： 将最终的和按位取反，得到校验和。 填入UDP校验和字段： 将计算出的校验和填入UDP报文的校验和字段。 示例 假设我们有以下数据： 源IP地址：192.168.1.1 目标IP地址：192.168.1.2 UDP数据部分：”hello” 构建伪首部 源IP地址：192.168.1.1 -&gt; 0xC0A80101 目标IP地址：192.168.1.2 -&gt; 0xC0A80102 保留字段：0x00 协议号：17（UDP） -&gt; 0x11 UDP长度：8字节（UDP首部） + 5字节（数据） &#x3D; 13字节 -&gt; 0x000D 伪首部为： 10xC0A80101 0xC0A80102 0x0011 0x000D UDP首部 假设： 源端口：12345 -&gt; 0x3039 目标端口：80 -&gt; 0x0050 长度：13字节（UDP首部 + 数据） -&gt; 0x000D 校验和字段：暂时设为0 -&gt; 0x0000 UDP首部为： 10x3039 0x0050 0x000D 0x0000 数据部分 “hello”的ASCII码： 10x6865 0x6C6C 0x6F00 （补0以凑成偶数字节） 拼接伪首部、UDP首部和数据部分 拼接后的字节流为： 1230xC0A8 0x0101 0xC0A8 0x0102 0x0011 0x000D0x3039 0x0050 0x000D 0x00000x6865 0x6C6C 0x6F00 求和 逐个相加（16位字）： 1230xC0A8 + 0x0101 + 0xC0A8 + 0x0102 + 0x0011 + 0x000D +0x3039 + 0x0050 + 0x000D + 0x0000 +0x6865 + 0x6C6C + 0x6F00 求和结果： 1234Sum = 0xC0A8 + 0x0101 + 0xC0A8 + 0x0102 + 0x0011 + 0x000D + 0x3039 + 0x0050 + 0x000D + 0x0000 + 0x6865 + 0x6C6C + 0x6F00 = 0x25C02 (包含进位) 处理进位： 10x25C02 -&gt; 0x5C02 + 0x2 = 0x5C04 取反： 1~0x5C04 = 0xA3FB 填入校验和字段 将0xA3FB填入UDP报文的校验和字段，这样UDP报文的校验和计算完成。 3.4 面向连接的传输 TCP3.4.1. 前置知识：可靠数据传输（Reliable Data Transfer，简称RDT ）原理rdt 在应用层、传输层和数据链路层都很重要。是网络 Top 10 问题之一。 信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性。信道的不可靠特的不可靠性表现在： 信道存在比特差错 分组在信道中传输可能会丢失 针对比特差错，可以增加检错重传机制：（此时假设信道只存在比特差错） 可以用校验和来检测比特差错。但是当对方检测出报文出错时，会将错误报文丢弃，如何让发送方重传呢？ &#x3D;&#x3D;&gt; 通过反馈机制响应确认码：ACK 确认(ACK)：接收方显式地告诉发送方分组已被正确接收 否定确认( NAK): 接收方显式地告诉发送方分组发生了差错。发送方收到NAK后，发送方重传分组 因此发送方还需要存在一个缓存，因为出错后要重传，将报文传出去后不能立马删除，而是要缓存起来。 机制大致如下： 发送方差错控制编码、缓存 接收方使用编码检错 接收方的反馈：控制报文（ACK，NAK）：接收方 –&gt;发送方 发送方收到反馈相应的动作 但是这样的机制还存在一个致命的问题，如果ACK &#x2F; NCK反馈报文出错了怎么办？ &#x3D;&#x3D;&gt; 给发送的报文添加序号，响应报文ACK或者NCK要跟着上一次成功接收的报文序号。 比如： 发送方有pk0和pk1要发送，缓存后发送pk0 , 等待响应。 接收方成功接收pk0,检错通过，发送ACK0给对方。 ACK0如果出错了，接收方无法知道这是ACK0，变成了“阿巴阿巴”，接收方看不懂，就继续重传没有收到确认的分组pk0 接收方还是正常收到pk0,因为有加序号，它知道这是重复的分组（状态会指示希望接收到的分组的序号），于是将其丢弃，响应ACK0 这次发送方正常收到ACK0，于是开始发送ACK1… 通过引入这种机制解决响应码出错的问题。运行时如图所示： 对上诉机制的优化：使用对前一个数据单位的ACK，代替本数据单位的NAK 接收方对最后正确接收的分组发ACK，以替代NAK 接收方必须显式地包含被正确接收分组的序号 发送方收到重复的ACK（如：再次收到ack0）时， 与收到NAK采取相同的动作：重传当前分组 为后面的一次发送多个数据单位做一个准备:一次能够发送多个分组，每一个的应答都有：ACK，NACK；比较麻烦 这样可以使确认信息减少一半，协议处理简单 出错了。接收方是不需要理解ACK0或者ACK1的含义，只负责接收ACKn , 下次我就传ACK n+1 : 解决了比特差错的问题之后，再来看看如果信道还存在着丢失如何处理（此时信道具有比特差错和分组丢失） 下层信道可 能会丢失分组（数据 或ACK）：发送方发出分组后在等ACK , 接收方在等分组，但这个分组已经丢了，这样就造成了死锁。 &#x3D;&#x3D;&gt; 解决方案：超时重传，发送方等待ACK一段合理的时间，如果到时没有收到ACK就认为分组丢失了，重传。 问题：如果分组（或ACK）只是被延迟了，发送方却提前重传了？ &#x3D;&#x3D;&gt; 重传将会导致数据重复，但利用序列号已经可以处理这个问题。因此接收方必须指明被正确接收的序列号（ACKn）。 过早超时也能正常工作，但是效率较低，一半 的分组和确认是重复的； 因此设置一个合理的超时时间也是比较重要的。 以上都是假设一次只能传送一个分组，这样传输模式信道的利用率很低。如何才能同时传多个分组呢？ &#x3D;&#x3D;&gt; 流水线协议：允许发送方在未得到对方确认的情况下一次发送多个分组 必须增加序号的范围:用多个bit表示分组的序号 在发送方&#x2F;接收方要有缓冲区 发送方缓冲：未得到确认，可能需要重传； 接收方缓存：上层用户取用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，要进行排序交付（可靠） 两种通用的流水线协议：回退N步(GBN)和选择重传(SR) 发送方的缓冲区： 形式：内存中的一个区域，落入缓冲区的分组可以发送 功能：用于存放已发送，但是没有得到确认的分组 必要性：需要重发时可用 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组（下图就是8个单位，编号 0 - 7 ， 一次最多可以发送8个未确认的分组） 停止等待协议 &#x3D;1 （stop and wait , 前面提到的） 流水线协议 &gt;1，合理的值，不能很大，链路利用率不能够超100% （pipeline） 发送缓冲区中有两类分组： 未发送的分组 已发送但是未确认的分组，这些分组只有收到ACK之后才能从缓冲区中删除（体现为滑动窗口前沿的移动） 工作流程分析：分组落入缓冲区中，初始时发送窗口（发送缓冲区内容的一个范围，是那些已发送但是未经确认分组的序号构成的空间）为0，没发送一个分组，发送窗口的后沿就向后移动1，上图发送窗口移动到了4，说明此时发生出去5个未确认的分组。当收到分组的确认后，发送窗口前沿向前移动，上图中收到了0和1号分组的确认，发送窗口前沿向前移动到了2。 接收窗口 接收窗口(receiving window)&#x3D;接收缓冲区 接收窗口用于控制哪些分组可以接收 只有收到的分组序号落入接收窗口内才允许接收 若序号在接收窗口之外，则丢弃； 接收窗口尺寸Wr&#x3D;1（GBN），则只能顺序接收。 接收窗口尺寸Wr&gt;1 (SR)，则可以乱序接收，但提交给上层的分组，要按序。 例子：Wr＝1，在0的位置；只有0号分组可以接收； 向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃； 接收窗口的滑动和发送确认： 滑动： 低序号的分组到来，接收窗口移动； 高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动 发送确认： 接收窗口尺寸&#x3D;1：发送连续收到的最大的分组确认（累计确认） 接收窗口尺寸&gt;1：收到分组，发送那个分组的确认（非累计确认） 想一下，这里wr &gt; 1的时候，能不能只发送窗口的最低(最左边)序号分组的那个确认，发送完再让窗口前沿往前移动？ 正常情况下发送窗口和接收窗口的交互： SR为例: 12345678910111213141516171819202122时间轴 -&gt;发送窗口 (初始): [0, 1, 2, 3]发送分组0, 1, 2, 3接收窗口 (初始): [0, 1, 2, 3]接收ACK0:发送窗口: [1, 2, 3, 4]接收窗口: [1, 2, 3, 4]接收分组2, 3:发送窗口: [1, 2, 3, 4]接收窗口: [1, 2, 3, 4]接收分组1:发送窗口: [4, 5, 6, 7]接收窗口: [4, 5, 6, 7]发送分组4, 5, 6, 7接收ACK4, 5, 6, 7:发送窗口: [8, 9, 10, 11]接收窗口: [8, 9, 10, 11] 异常情况下GBN协议的发送窗口和接收窗口的交互： 异常情况下SR协议的发送窗口和接收窗口的交互： GBN和SR的对比： 相同之处： 发送窗口&gt;1 一次能够可发送多个 未经确认的分组 不同之处： GBN:接收窗口尺寸&#x3D;1 接收端：只能顺序接收 发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4 ; 假如1未成功，234都发送出去 了，要返回1再发送；GB1 发送端拥有对最老的未确认分组的定时器。只需设置一个定时器，当定时器到时时，重传所有未确认分组 SR: 接收窗口尺寸&gt;1 接收端：可以乱序接收 发送端：发送0,1,2,3,4，一旦1 未成功，2,3,4,已发送，无需重发，选择性发送1 发送方为每个未确认的分组保持一个定时器，当超时定时器到时，只是重发到时的未确认分组 3.4.2 TCP的具体实现特点概述： 点对点： 一个发送方，一个接收方 可靠的、按顺序的字节流：没有报文边界 管道化（流水线）： TCP根据调整窗口大小进行拥塞控制和流量控制 发送和接收缓存 全双工数据： 在同一连接中数据流双向流动；MSS：最大报文段大小 面向连接： 在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量 报文结构： 序号：报文段首字节的在字节流的编号 在TCP传输过程中，序号（Sequence Number）字段用于跟踪每个字节的数据顺序。当传输端（发送方）从上层接收到一个message并封装成TCP报文段时，它会使用一个随机生成的初始序号（Initial Sequence Number, ISN）。后续的TCP报文段的序号将基于这个初始序号递增。 建立连接时：在三次握手过程中，双方交换初始序号。例如，A发送的SYN报文段中包含初始序号（ISN_A），B响应的SYN-ACK报文段中包含B的初始序号（ISN_B）。 数据传输时：每个报文段的序号字段标记了该段中第一个数据字节的序号。例如，如果A的初始序号是1000，且A发送了100字节的数据，那么A发送的第一个报文段的序号字段将是1000，第二个报文段的序号字段将是1100（因为第一个报文段包含100个字节的数据）。 确认号：期望从另一方收到的下一个字节的序号；累积确认（发送方收到ACKn , 就会发出pktn） 乱序接收：没有规定接收方如何处理乱序的 报文段（但是一般都是先缓存而不会直接丢弃） TCP 协议虽然没有强制规定接收方必须采取的具体处理方式，但在实际实现中，接收方一般会采用接收缓冲区来处理乱序的报文段。这种方式确保了可靠性和有效性。如果接收方简单地丢弃乱序的报文段，确实会导致传输效率低下甚至错误，因此大多数 TCP 实现不会这样做 设置合理的超时时间： 超时时间设置为一个RTT（加权过后）+ 4被方差。可以理解为比一个往返时长再多一点点 TCP的rdt实现： TCP在IP不可靠服务的基础上 建立了rdt： 管道化的报文段（ GBN or SR） 累积确认，响应期望收到的下一个分组的序号，也可以说是顺序收到的最后一个字节的数据编号 + 1（像GBN） 单个重传定时器（像GBN） 没有规范是否可以接受乱序 通过以下事件触发重传： 超时（只重发那个最早的未确认段：SR） 重复的确认（例子：收到了ACK50,之后又收到3 个ACK50） 快速重传超时周期往往太长： 在重传丢失报文段之前的延时太长，通过重复的ACK来检测 报文段丢失。发送方通常连续发送大量 报文段。如果报文段丢失，通常会引起多个重复的ACK 发送方事件： 从应用层接收数据 –&gt; 将应用层数据分段，并为每个报文段分配序列号 –&gt; 将报文段放入发送缓冲区 –&gt; 通过网络发送 定时器与最早未确认的报文 段关联 收到对尚未确认的报文段确认，则更新已被确认的报文序号。如果当前还有未被确认的报文段，重新启动定时器 流量控制: 接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。 解决方法： 接收方在其向发送方的TCP段 头部的rwnd字段“通告”其空 闲buffer大小 大小通过socket选项 设置(典型默认大小为4096 字 节) 很多操作系统自动调整 发送方限制未确认(“in flight”)字节的个数 ≤ 接收方发送过来的值，保证接收方不会被淹没 连接管理： 在正式交换数据之前，发送方和接收方握手建立通 信关系。目的： 同意建立连接（每一方都知道对方愿意建立连接） 交换连接参数 使用两次握手可以吗？ 会存在半连接以及接收旧数据的问题， 对于场景1：如果客户端第一次的连接请求超时了，它会重发一个连接请求与服务器建立起了连接。这时前面的那个连接到了服务器这里，服务器就与它建立起了连接，给它准备连接资源。但这只是个半连接，客户端不认，只有服务器在维持，白白浪费了资源。 对于场景2：客户端与服务器建立起连接之后，连接请求和传送的数据都超时了，而且都在连接断开之后到达了服务器，服务器还是会建立连接并且接收数据。 改进：3次握手来建立起连接 这样也能解决前面的失败场景： 当旧连接到达服务器的时候，服务器会再向客户端发送一个确认连接，客户端可以拒绝或者不理，这样连接过程就不完整（只有2次握手），无法建立起连接。对于旧数据也是如此，半连接建立不起来，更别说传数据了。 在连接结束之后需要关闭连接：4次挥手 客户端，服务器分别关闭它自己这一侧的连接。客户点等待一段时间之后发现没有数据过来了，就关闭。 可以联想，两个人分别的时候，A先说要回家了： A -&gt; B : 阿B，我要回家啦 B -&gt; A ：好 B也要说一下自己走了 B -&gt; A ：那我也回家啦 A -&gt; B：ok~ 然后A目送B离开，自己也转身迈步离开。 3.5 TCP的拥塞控制前置知识：拥塞控制原理4. 网络层5. 链路层","categories":["计算机基础","计算机网络"]},{"title":"java日志库","path":"/2024/04/12/java日志库/","content":"总结一下java日志库的相关知识以及日志库的选型和基本用法 初始：一个日志库的使用例子通过一个使用log4j2 + slf4j的案例初步认识日志库的使用： 创建pom项目，引入相关依赖： 123456789101112131415161718&lt;!-- SLF4J API --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.32&lt;/version&gt;&lt;/dependency&gt;&lt;!-- SLF4J binding for Log4j 2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.17.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Log4j 2 implementation --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.17.1&lt;/version&gt;&lt;/dependency&gt; 在项目中配置 Log4j 2 的日志记录器。创建一个 log4j2.xml 文件来配置日志记录器。 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;debug&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 在代码中使用 SLF4J API 进行日志记录 12345678910111213package org.example;import com.sun.tools.javac.Main;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class App &#123; private static final Logger logger = LoggerFactory.getLogger(Main.class); public static void main(String[] args) &#123; logger.info(&quot;This is an info message&quot;); logger.error(&quot;This is an error message&quot;, new RuntimeException(&quot;Oops! Something went wrong.&quot;)); &#125;&#125; 查看日志输出 在这个案例中，使用了slf4j的api进行日志输出，log4j2负责在程序运行时生成并记录日志，而程序开发人员使用slf4j提供的api来指定日志的记录。 在引入依赖时，分别引入了slf4j的api ： slf4j-api、log4j2的日志功能的实现：log4j-core，以及选择log4j-slf4j-impl作为slf4j和log4j2的桥接包，让slf4j 与实现日志功能的log4j绑定。这样就可以使用slf4j的api调用log4j2提供的日志功能。这种设计模式成为门面模式（Facade Pattern 可参考：https://www.runoob.com/w3cnote/facade-pattern-3.html）。 在 Java 中，日志库通常使用门面模式来提供统一的接口，以便开发人员可以方便地切换不同的日志实现，而不必修改应用程序的代码。门面模式隐藏了底层组件的复杂性，并提供了一个简单的接口供客户端使用。 SLF4J（Simple Logging Facade for Java）是一个典型的例子，它就是使用了门面模式。SLF4J 提供了一个简单的抽象接口，开发人员可以在应用程序中使用这个接口来记录日志，而不用关心底层日志库的具体实现。然后，通过在类路径中引入相应的日志实现（如Log4j、Logback等），SLF4J 会自动找到并绑定到这些实现，从而实现日志记录功能。 日志库 — 日志门面在 Java 中，有几个常见的日志门面框架，它们为开发人员提供了统一的日志记录接口，使得在应用程序中记录日志变得更加灵活和可移植. SLF4J (Simple Logging Facade for Java)SLF4J 是一个简单的日志门面框架，它允许开发人员在应用程序中使用统一的 API 来记录日志。SLF4J 提供了一组接口，开发人员可以使用这些接口来记录日志消息，而不用关心底层日志库的具体实现。SLF4J 还提供了与不同日志实现（如Log4j、Logback等）集成的机制，通过引入相应的日志实现，可以将 SLF4J 绑定到具体的日志库上。 类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。 使用SLF4j的过程中遇到的各种警告可以去https://www.slf4j.org/codes.html 里查看问题描述，基本都有解答。 使用 SLF4J 的主要步骤： 添加 SLF4J 依赖: 在项目的构建文件中（如 Maven 的 pom.xml 文件）添加 SLF4J 的依赖。 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.32&lt;/version&gt;&lt;/dependency&gt; 引入日志实现: SLF4J 是一个日志门面，它本身并不提供日志记录的实现，需要引入具体的日志实现。例如，可以引入 Logback 作为日志实现。(Logback 提供了自己的实现，并在其中包含了 SLF4J 的 API。因此不需要额外引入桥接器来使 SLF4J 与 Logback 集成，只需添加 logback-classic 依赖即可) 12345&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 在代码中使用 SLF4J API 进行日志记录： 12345678910111213javaCopy codeimport org.slf4j.Logger;import org.slf4j.LoggerFactory;public class MyClass &#123; private static final Logger logger = LoggerFactory.getLogger(MyClass.class); public void myMethod() &#123; logger.debug(&quot;Debug message&quot;); logger.info(&quot;Info message&quot;); logger.warn(&quot;Warning message&quot;); logger.error(&quot;Error message&quot;); &#125;&#125; Apache Commons Logging (JCL)Apache Commons Logging 是另一个常见的日志门面框架，它提供了一个简单的接口，允许开发人员在应用程序中记录日志消息。JCL 具有类似于 SLF4J 的功能，但它的设计更加简单，没有 SLF4J 那么灵活和强大。 JCL本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。 与 SLF4J 不同的是，JCL 并没有像 SLF4J 那样支持多种日志实现，而是将日志记录的实现交由第三方提供。 使用 Apache Commons Logging 的主要步骤： 添加 Apache Commons Logging 依赖: 在项目的构建文件中（如 Maven 的 pom.xml 文件）添加 Apache Commons Logging 的依赖。 12345&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 引入日志实现: 与 SLF4J 不同，Apache Commons Logging 并不要求引入特定的日志实现。开发人员可以根据需求选择任何支持 Apache Commons Logging 的日志实现，如 Log4j、Logback 等。 在代码中使用 Apache Commons Logging API 进行日志记录： 12345678910111213import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class MyClass &#123; private static final Log logger = LogFactory.getLog(MyClass.class); public void myMethod() &#123; logger.debug(&quot;Debug message&quot;); logger.info(&quot;Info message&quot;); logger.warn(&quot;Warning message&quot;); logger.error(&quot;Error message&quot;); &#125;&#125; 需要注意的是，在使用 Apache Commons Logging 时，需要确保项目的类路径中包含了选定的日志实现（如 Log4j、Logback），否则无法正常记录日志。 日志库 — 日志实现日志实现库提供了用于记录应用程序日志的具体实现。这些库通常与日志门面框架（如SLF4J或Apache Commons Logging）配合使用，以提供统一的日志记录接口，并允许开发人员根据需要选择适当的日志实现。 Log4j 1.xLog4j 是 apache 的一个开源项目，创始人 Ceki Gulcu。它提供了成熟的日志记录功能，是 Java 领域资格最老，应用最广的日志工具。Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。 Log4j 中有三个主要组成部分： loggers - 负责捕获记录信息。 appenders - 负责发布日志信息，以不同的首选目的地。 layouts - 负责格式化不同风格的日志信息。 优点： 成熟稳定: Log4j 1.x 是一个成熟的日志框架，在很长一段时间内被广泛应用和验证。 功能丰富: 提供了丰富的功能和配置选项，适用于各种日志需求。 缺点： 性能不如后续版本: 相比于 Log4j 2 和 Logback，性能略逊一筹。 维护状态: Log4j 1.x 的维护状态已经停止，不再推荐新项目使用 使用方法： 添加 Log4j 1.x 的依赖到项目中。 创建 log4j.properties 或 log4j.xml 配置文件，配置日志记录器、输出目标等。 在代码中使用 Log4j 1.x 的 API 进行日志记录。 Log4j 2维护 Log4j 的人为了性能又搞出了 Log4j2。Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J&#x2F;Logback，提供了异步日志记录、插件架构、灵活的配置选项等特性，被广泛用于 Java 应用程序的日志记录，性能上也获得了很大的提升。 Log4j2 也做了 Facade&#x2F;Implementation 分离的设计，分成了 log4j-api 和 log4j-core。 优点： 高性能: Log4j 2 针对性能进行了优化，特别是在异步日志记录方面，可以提供较高的吞吐量。 灵活的配置: Log4j 2 提供了丰富的配置选项，允许开发人员通过 XML、JSON、YAML 或编程方式配置日志记录器。 插件架构: Log4j 2 使用插件架构，可以轻松地扩展功能，添加新的日志输出目标、格式化器等。 支持多种日志级别: 支持调试、信息、警告、错误、致命等多种日志级别。 与 SLF4J 集成: 可以与 SLF4J 集成，使得在应用程序中记录日志更加灵活和可移植。 缺点： 配置相对复杂: 配置文件的格式较为复杂，需要一定的学习成本。 资源占用较高: 相对于其他日志库，可能会占用较多的资源。 使用方法： 添加 Log4j 2 的依赖到项目中。 创建 log4j2.xml 或 log4j2.yaml 等配置文件，配置日志记录器、输出目标等。 在代码中使用 SLF4J 或 Log4j 2 的 API 进行日志记录。 LogbackLogback 是由 Log4j 的作者开发的日志框架，被设计成 Log4j 的改进版。它具有与 Log4j 相似的功能，但在性能上有所提升。Logback 提供了异步日志记录、灵活的配置选项等特性，同时与 SLF4J 集成，使得在应用程序中记录日志变得更加灵活和可移植。 logback 当前分成三个模块：logback-core、logback-classic 和 logback-access。 logback-core ：是其它两个模块的基础模块。 logback-classic ：是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j 或 JDK14 Logging。 logback-access ： 访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能。 优点： 性能优秀: Logback 是 Log4j 的改进版，性能较好，特别是在并发环境中表现突出。 简单配置: Logback 的配置相对简单，易于上手。 与 SLF4J 集成: 可以与 SLF4J 集成，提供了统一的日志记录接口。 缺点： 社区活跃度较低: 相比于 Log4j 2，Logback 的社区活跃度可能稍低。 插件数量相对较少: 插件数量不及 Log4j 2 多。 使用方法： 添加 Logback 的依赖到项目中。 创建 logback.xml 配置文件，配置日志输出目标、格式化器等。 在代码中使用 SLF4J 或 Logback 的 API 进行日志记录。 java.util.logging (JUL)JUL是 Java 平台自带的日志框架，也称为 JDK 日志框架。它提供了基本的日志功能，包括日志记录器、日志处理器、日志格式化器等，可以在大多数 Java 应用程序中直接使用，而无需额外的依赖。 虽然是官方自带的log lib，JUL的使用确不广泛。原因有以下几点： JUL从JDK1.4 才开始加入(2002年)，当时各种第三方log lib已经被广泛使用了 JUL早期存在性能问题，到JDK1.5上才有了不错的进步，但现在和Logback&#x2F;Log4j2相比还是有所不如 JUL的功能不如Logback&#x2F;Log4j2等完善，比如Output Handler就没有Logback&#x2F;Log4j2的丰富，有时候需要自己来继承定制，又比如默认没有从ClassPath里加载配置文件的功能 使用方法： 在代码中直接使用 java.util.logging 包中的类进行日志记录。 可以通过配置文件或代码配置日志记录器、处理器等。 日志库的选型与具体使用 使用日志库通常涉及3个基本步骤： 引入对应的依赖 配置日志实现组件 使用API 重点在于引入依赖，因为配置和api的使用不同的日志门面和日志实现基本相同。 正确引入对应的依赖 使用logback + slf4j 直接引入logback-classic 即可 123456&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; logback-classic会自动将 slf4j-api 和 logback-core也添加到项目中: slf4j + log4j 直接引入slf4j-log4j12 它会一起引入slf4j-api 和 log4j 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt; 也可以分别引入slf4j-api、log4j-slf4j-impl、log4j-core，比较麻烦，还要注意版本有没有冲突 slf4j + jul 直接引入slf4j-jdk14，它会自动添加相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt; &lt;version&gt;2.0.12&lt;/version&gt;&lt;/dependency&gt; slf4j兼容非slf4j组件 — 桥接假如应用程序所调用的组件当中已经使用了 common-logging，这时需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图 无论项目中使用的是 common-logging 或是直接使用 log4j、java.util.logging，都可以使用对应的桥接 jar 包来解决兼容问题。 slf4j 兼容 common-logging 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; slf4j 兼容 log4j 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; slf4j 兼容 java.util.logging 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; spring 集成 slf4j 做 java web 开发，基本离不开 spring 框架。很遗憾，spring 使用的日志解决方案是 common-logging + log4j。 所以，你需要一个桥接 jar 包：logback-ext-spring。 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt; &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt; &lt;version&gt;0.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 使用日志库时的注意事项 不要直接使用日志实现组件 使用日志门面（如 SLF4J）能使代码与特定的日志实现解耦。如果将来需要更换或升级日志实现，只需更改配置和依赖，而不需要修改代码。 直接使用日志实现组件会导致代码与特定的日志实现紧密耦合在一起。这样的设计不利于代码的可移植性和重用性。 在一个大型的应用或者多模块项目中，可能会使用多个库或框架，它们可能依赖于不同版本的同一个日志库。如果直接使用日志实现，可能会导致类路径冲突和版本冲突，增加了解决问题的难度。 使用日志门面可以更容易地进行性能优化和适配。日志门面可以为不同的日志实现提供适配器，以优化性能或适应特定的环境。 通过日志门面，可以更容易地统一日志的格式和风格，无论使用哪种日志实现。这有助于提高日志的可读性和统一性。 只引入一个具体的日志实现组件 解决dubbo那个issue的时候就遇到了这个问题，有一个模块在pom里直接引入了logf42作为日志实现，而引入的dubbo-zookeeper-curator5-spring-boot-starter里面又没有排除掉logback。导致在类路径里引入了多个日志实现。就会有警告，并且slf4j会自己选择其中一个作为实现。 那这么看来，应该算是dubbo-zookeeper-curator5-spring-boot-starter这个stater的问题，它应该把logback的依赖设置为optional，不应该直接传递过来。（可以去提个issue并解决） 如果引入多个日志实现组件，可能会导致类路径冲突、不一致的日志行为或者混乱的日志输出。这可能会增加维护成本，并且在解决问题时可能会变得非常困难。 每增加一个日志实现组件都会增加项目的复杂性。不同的日志实现可能有自己特有的配置、API和行为，这会增加学习成本和维护难度。 只使用一个日志实现组件可以确保日志输出的一致性和统一性，有助于更好地理解和分析日志信息。 具体的日志实现依赖应该设置为optional和使用runtime scope 在项目中，Log Implementation的依赖强烈建议设置为runtime scope，并且设置为optional。例如项目中使用了 SLF4J 作为 Log Facade，然后想使用 Log4j2 作为 Implementation，那么使用 maven 添加依赖的时候这样设置: 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的Log Implementation 依赖；Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不使用Log Facade中的类。 必要时排除依赖的第三方库中的Log Impementation依赖 这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为optional，然后你的项目继承了这些依赖——具体的日志实现未必是你想使用的，比如他依赖了Log4j，你想使用Logback，这时就很尴尬。另外，如果不同的第三方依赖使用了不同的桥接器和Log实现，也极容易形成环。 这种情况下，推荐的处理方法，是使用exclude来排除所有的这些Log实现和桥接器的依赖，只保留第三方库里面对Log Facade的依赖。 这个也在上次解决issue的时候见到了： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 这个为了排除掉springboot自带的日志实现logback。因为项目中使用的是log4j2。如果不exclude的话，可能会造成日志冲突。 当时是log4j-to-slf4j在springboot-starter里面有引入；log4j-slf4j2-impl在spring-boot-starter-log4j2里面。这两个桥接器造成了冲突。","tags":["java"],"categories":["编程学习","java"]},{"title":"test","path":"/2024/04/11/test/","content":"咋样才能更方便地使用图片啊： 使用全局文件夹&#x2F;assets&#x2F;，使用markdown的语法![](url) 配置post_asset_folder: true 每次new 文章的时候会创建一个同名资源文件夹。 直接使用相对路径 使用插件的语法 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; {} 图片是放在assets还是当前的资源文件夹 使用emoji："},{"title":"记录第一次在开源社区提交pr的过程","path":"/2024/04/11/记录第一次在开源社区提交pr/","content":"记录解决dubbo社区issue的过程！这是一个good-first-issue，比较适合社区的新人。我刚看到issue描述的时候觉得很容易完成，更新相关依赖不就可以了，几分钟就搞定了吧。然而当我第一次push到仓库进行ci测试之后，才真正见识到了依赖版本冲突的可怕… issue描述https://github.com/apache/dubbo/issues/13862 component： Java Samples (apache&#x2F;dubbo-samples) description： Dubbo Samples switched the required JDK version to OpenJDK17. Dubbo Samples are entirely switched to SpringBoot3. related： https://github.com/apache/dubbo/discussions/13841 关于issue的讨论，用处不大 https://github.com/apache/dubbo-samples/pull/1057 别人提交过的pr，可以参考 https://github.com/apache/dubbo-samples/pull/1089 背景调研 apache&#x2F;dubbo-samples仓库是干什么的？ 用来演示dubbo的用途。里面有很多个子项目，分别展示了dubbo从基础到进阶的各种用法。 利用这些sample通过docker来进行dubbo的集成测试。 这些samples怎么运行？ 直接clone之后找到自己想要的某个sample，单独构建运行一个子项目。不要直接运行整个项目，太大了。 12$ cd 1-basic/dubbo-samples-spring-boot$ mvn clean package 具体描述issue是要做什么事情? 把这些sample的jdk版本更新到jdk17。之前可能用的比较老的版本。springboot3最低支持JDK 17 ，不再支持JDK 17之前的版本。 所以这些samples是为了更新springboot的版本，比如springboot3。因此也要更新jdk版本。 猜测sample里的项目大多都是基于springboot开发的，因此更新这个仓库里的所有项目需要很大的工作量。他才会让我们只负责单独的某个或几个模块。 相关的那个pr是做了什么事情？ 把相关项目的pom文件的java版本target和source改为17，springboot版本改为3.2： 解决过程 找到项目对应模块中使用到springboot的地方，将pom文件的属性改一下就行。 测试失败！！！ springcloud的服务提供者provider可以正常启动。 Dubbo Client服务调用方无法正常启动： 查看日志发现报错：在注册中心里面找不到provider。 将分支切换回master,使用原来的测试用例启动provider时，可以在nacos的控制台查看注册的服务列表： 这个服务是有注册上的。而报错的分支却没有注册服务。因此，问题出在更新代码之后provider没有办法正常在nacos注册。 springboot和springcloud是有版本的对应关系的，我刚刚只更新了springboot的版本而没有同步更新cloud的版本，导致出现了问题。 在spring的官网查看spring官网查看springboot和springcloud的版本对应关系： 查看springboot与springcloudalibaba的版本对应关系： https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB 将spring-cloud和spring-cloud-alibaba的版本更新后，全部正常。提交看看CI测试。不通过。 wc,把另一个模块给忘了。赶紧把sc-call-dubbo的模块也改了 : 以来都改了之后，手动调用是正常的。 但是测试用例却通过不了： 1234567891011121314151617181920212223242526@Test public void test() &#123; String url = String.format(&quot;http://%s:8099/dubbo/rest/test1&quot;, consumerAddress); RestTemplate restTemplate = new RestTemplate(); UserList userList = restTemplate.getForObject(url, UserList.class); assert userList != null; Assert.assertEquals(1, userList.getUsers().size()); &#125; public class UserList &#123; private List&lt;User&gt; users; public UserList() &#123; users = new ArrayList&lt;&gt;(); &#125; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; &#125; 报错信息提示：在将调用返回的结果json转为UserList的时候发生了错误。 自己在浏览器调用应用的服务拿到返回数据： 1[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Dubbo provider!&quot;&#125;] 这是一个json数组，里面包含一个对象。这个对象有两个属性 id 和 name。对应着sample里的实体类User。用UserList来接收json反序列化后的对象，即一个对象里面有一个类型为数组的属性。与返回数据不匹配啊，直接返回的是一个数组。把测试用例改一下试一试： 1234567891011@Test public void test() &#123; String url = String.format(&quot;http://%s:8099/dubbo/rest/test1&quot;, consumerAddress); RestTemplate restTemplate = new RestTemplate(); // 直接解析为 List&lt;User&gt; List&lt;User&gt; userList = restTemplate.getForObject(url, List.class); Assert.assertNotNull(userList); Assert.assertEquals(1, userList.size()); &#125; ok,本地测试通过了。但是ci测试还是不通过。 55个测试只通过了49个。 查看详细的日志，一直是这两个模块environment-keys和call-back的问题: Dubbo 3.3 &#x2F; Test Result (Java17) Dubbo 3.3 &#x2F; Test Result (Java21) integration Test (Java17, Job3) integration Test (Java21, Job3) 日志框架出现了多个绑定：https://www.slf4j.org/codes.html#multiple_bindings integration Test (Java17, Job4) integration Test (Java21, Job4) Integration Test Job3失败的原因在于：environment-keys-provider出现了多个日志实现。 Integration Test Job4失败的原因在于：callback-consumer无法连接找到provider提供的服务。 而test result失败就是因为有了这两个job的失败，在merge test result时会出现两个失败的case。 在java17和java21版本各有3个failures，所以一共有6个不通过的ci测试。 只要解决Integration Test Job3和Integration Test Job4即可。 着手解决job3: 123456789101112131415161718192021SLF4J(W): Class path contains multiple SLF4J providers.SLF4J(W): Found provider [org.apache.logging.slf4j.SLF4JServiceProvider@3cd1f1c8]SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@3a4afd8d]SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J(I): Actual provider is of type [org.apache.logging.slf4j.SLF4JServiceProvider@3cd1f1c8]Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError\tat org.apache.dubbo.samples.environment.keys.provider.ProviderApplication.main(ProviderApplication.java:28)Caused by: org.apache.logging.log4j.LoggingException: log4j-slf4j2-impl cannot be present with log4j-to-slf4j\tat org.apache.logging.slf4j.Log4jLoggerFactory.validateContext(Log4jLoggerFactory.java:70)\tat org.apache.logging.slf4j.Log4jLoggerFactory.newLogger(Log4jLoggerFactory.java:50)\tat org.apache.logging.slf4j.Log4jLoggerFactory.newLogger(Log4jLoggerFactory.java:33)\tat org.apache.logging.log4j.spi.AbstractLoggerAdapter.getLogger(AbstractLoggerAdapter.java:53)\tat org.apache.logging.slf4j.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:33)\tat org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:422)\tat org.apache.commons.logging.LogAdapter$Slf4jAdapter.createLocationAwareLog(LogAdapter.java:121)\tat org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:95)\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67)\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59)\tat org.springframework.boot.SpringApplication.&lt;clinit&gt;(SpringApplication.java:202)\t... 1 more 在应用程序中，发现了多个 SLF4J 的提供者， org.apache.logging.slf4j.SLF4JServiceProvider@3cd1f1c8 ch.qos.logback.classic.spi.LogbackServiceProvider@3a4afd8d 这只是警告，它也自己选了ch.qos.logback.classic.spi.LogbackServiceProvider@3a4afd8d这个实现。 在错误消息指出了 log4j-slf4j2-impl 和 log4j-to-slf4j 不能同时存在。这是因为这两个依赖提供了不同的方式来桥接 Log4j 和 SLF4J，而它们之间可能会发生冲突。解决这个问题的方法通常是排除其中一个冲突的依赖，以确保只有一个 SLF4J 的实现被加载。 idea里打开dubbo.samples.environment.keys.provider模块，在maven插件里搜索这两个依赖： 发现log4j-to-slf4j是在spring-boot-starter里的spring-boot-logging引入的 而log4j-slf4j2-impl则是在spring-boot-starter-log4j2里引入的。 删除它们中的任意一个依赖就可以了。 ps : 我当时思路还没这么清晰，在引入spring-boot-starter的时候把spring-boot-logging排除掉： (其实在这里还有一个问题，在dubbo.samples.environment.keys.provider的父模块里进行依赖管理(标签)的时候，已经把这个spring-boot-starter-logging给排除了，子模块直接引入spring-boot-starter的时候为什么还是把它引进来了？) 123456789101112&lt;!-- spring starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 还顺手把spring-boot-starter-log4j2依赖给删了，本来以为这样会破坏它的日志系统，因为删掉了日志实现组件。但是这是没问题的，因为在dubbo-zookeeper-curator5-spring-boot-starter这个依赖里面它引入了logback-classic ，所以在这个模块里的日志库使用的是log4j + logback。 奈斯奈斯！！！job3解决！！！ 接下来解决job4: 1234567891011121314---------------------------------------------------------- dubbo-samples-callback log: callback-consumer.log----------------------------------------------------------Start at: 2024-04-09 12:34:51Waiting ports before run test ..checking tcp ports: callback-provider:2181;callback-provider:20880;, start at: 0, timeout: 180checking tcp port [callback-provider:2181] ...telnet: Unable to connect to remote host: Connection refusedTrying 192.168.48.2...telnet: Unable to connect to remote host: Connection refusedTrying 192.168.48.2...Trying 192.168.48.2...Connected to callback-provider.Escape character is &#x27;^]&#x27;. callback-consumer找不到provider,连接超时了哇。猜测是provider无法正常在Zookeeper注册。 运行一下测试用例,发现了一个错误信息： 12312:59:33.141 [ZooKeeper Server Starter] INFO org.apache.zookeeper.audit.ZKAuditProvider -- ZooKeeper audit is disabled.12:59:33.688 |-ERROR [main] org.apache.dubbo.common.Version:111 -| [DUBBO] Inconsistent version 3.2.3 found in dubbo-zookeeper-curator5-spring-boot-starter from file:/D:/devTool/Maven/maven-repository/org/apache/dubbo/dubbo-zookeeper-curator5-spring-boot-starter/3.2.3/dubbo-zookeeper-curator5-spring-boot-starter-3.2.3.jar!/META-INF/versions/dubbo-zookeeper-curator5-spring-boot-starter, expected dubbo-common version is 3.3.0-beta.1, dubbo version: 3.3.0-beta.1, current host: 169.254.123.149, error code: 0-12. This may be caused by , go to https://dubbo.apache.org/faq/0/12 to find instructions. 12:59:33.692 |-ERROR [main] org.apache.dubbo.common.Version:111 -| [DUBBO] Inconsistent git build commit id 8256e5646f5589bced5c458db586cae70cd16e2f found in dubbo-zookeeper-curator5-spring-boot-starter from file:/D:/devTool/Maven/maven-repository/org/apache/dubbo/dubbo-zookeeper-curator5-spring-boot-starter/3.2.3/dubbo-zookeeper-curator5-spring-boot-starter-3.2.3.jar!/META-INF/versions/dubbo-zookeeper-curator5-spring-boot-starter, expected dubbo-common version is 0c9d5e2f7383760018db38877863d6fc16fd6689, dubbo version: 3.3.0-beta.1, current host: 169.254.123.149, error code: 0-12. This may be caused by , go to https://dubbo.apache.org/faq/0/12 to find instructions. 这个错误消息表明在项目中发现了不一致的 Dubbo 版本信息。Dubbo 在运行时发现了一个与预期版本不一致的组件，这可能导致一些问题。在日志中，Dubbo 发现了一个名称为 dubbo-zookeeper-curator5-spring-boot-starter 的组件，其版本为 3.2.3，但是 Dubbo 期望的版本是 3.3.0-beta.1。 soga，原来是starter的版本跟dubbo版本冲突了！！ 那就把dubbo-zookeeper-curator5-spring-boot-starter改为3.3.0-beta.1 完美解决！！！ 总结梳理一遍流程： springcloud模块： 更新相关依赖 更新test case 更新test-case configuration environment-keys的consumer和provider模块： 删除spring-boot-starter-log4j2依赖 （其实排除dubbo-zookeeper-curator5-spring-boot-starter里的logback更好） 在spring-boot-starter里面排除logging callback模块: 修改dubbo-zookeeper-curator5-spring-boot-starter版本 修改日志依赖 可是我刚刚去测试了一遍如果不删除spring-boot-starter-log4j2的依赖，callback和environment-keys模块还是会有那个警告… 那个警告来自slf4j,提示你在项目的classpath里面引入了两个日志实现log4j2和logback,移除掉其中一个就好了。 但是在maven的依赖树里查找就不存在 log4j-slf4j2-impl 和 log4j-to-slf4j 同时存在的问题。 总结一下这次解决issue的收获： 做事情要专注并且持续地做完。不能像上次解决issue的时候三天打鱼两天晒网，断断续续地，最后没有完成任务。 看日志要有耐心并且仔细，快速定位到问题。不要日志随便一扫就盲目靠感觉去试，那样子成功了只是运气好，一定要学会好好分析问题。 需要学习一下GitHub ci的相关知识，这样有助于更好理解ci测试failure是为什么 需要重新复习java的日志库，日志系统和日志门面又忘了。刚好这次遇到了日志框架冲突的问题，可以结合这个例子加深一下印象。 Appendix过了5天终于把我的pr合并啦~ 还给我点了个赞，非常开心！！！ 又回来这个仓库看看，发现项目中使用的日志框架都是slf4j + log4j2。而在我提交的pr中，把两个模块的日志框架改成了logback + slf4j。这和项目不统一，应该修改。同时在项目中也存在着许多日志警告的问题，大都是在引入dubbo-zookeeper-curator5-spring-boot-starter的时候没有排除掉对应的依赖。 下面列出存在问题的模块： dubbo-samples-cache 、dubbo-samples-group 、dubbo-samples-mock 、dubbo-samples-notify 、dubbo-samples-rpccontext 、dubbo-samples-service-discovery 、dubbo-samples-spring-security 、dubbo-samples-validation ：存在多个日志实现的警告（原因：引入dubbo-zookeeper-curator5-spring-boot-starter没有排除logback；这个版本3.3.0-beta.2-SNAPSHOT已经将日志依赖设置为optional，3.3.0-beta.1 则会存在这个问题） dubbo-samples-callback 、 dubbo-samples-environment-keys 使用了logback , 而不是项目统一的log4j2 对于存在多个日志实现的警告，解决方法有两种： 在引入依赖时手动排除掉logback的相关依赖 引入新版本的dubbo-zookeeper-curator5-spring-boot-starter , 及3.3.0-beta.2，这个版本已经不会自动将日志实现一起引入。 对于日志框架不统一的问题，需要自己再手动解决： 在依赖管理中排除dubbo-zookeeper-curator5-spring-boot-starter中的logback相关依赖 引入slf4j2的相关依赖","tags":["dubbo"],"categories":["编程学习","参与开源社区"]},{"title":"深入理解java泛型","path":"/2024/03/27/深入理解java泛型/","content":"认识java的泛型机制泛型机制（Generics）是一种编程语言特性。允许在编写代码时使用参数化类型。它允许开发者在设计类、接口和方法时使用类型参数，这些类型参数可以在使用时被实际的类型替换。泛型机制的主要目的是增加代码的灵活性、可重用性和类型安全性。 我们通过一个简单的例子认识java的泛型以及感受一下泛型的好处： 假设我们需要实现一个加法功能，支持多种数据类型进行相加。 我们可以使用重载写多个add方法： 1234567891011121314private static int add(int a, int b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static float add(float a, float b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static double add(double a, double b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125; 这样做每种类型都需要重载一个add方法；而通过泛型，我们可以复用为一个方法： 12345//这里定义了一个泛型方法，返回值类型为double,方法接收的参数类型为Number类型及其子类。private static &lt;T extends Number&gt; double add(T a, T b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue();&#125; 再看这个例子，向一个集合dogs中添加3个Dog对象： 123456789101112131415161718192021222324252627class Dog &#123; private String name; Dog()&#123;&#125; Dog(String name) &#123; this.name = name; &#125;&#125;class Cat &#123; private String name; Cat()&#123;&#125; Cat(String name) &#123; this.name = name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; //传统写法 List dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //手动类型转换 Dog dog1 = (Dog)dogs.get(0); &#125;&#125; 这样写存在什么问题呢？ 需要手动进行类型转换：因为我们在声明List的时候并没有指定集合当中元素的类型，ArrayList只是维护了一个Object引用的数组。我们接收这个对象就需要进行一次类型转换：Dog dog1 = (Dog)dogs.get(0); 进行强制类型转换效率较低，并且可能会抛出类转换异常ClassCastException。而这个异常我们无法在编译中发现，只能在运行时才能发现，存在安全隐患。 不能对集合中元素的类型进行约束：在我们的需求中是往dogs中添加Dog对象。但是如果我向集合中添加其他类型的元素编译时却不会有任何错误提示：dogs.add(new Cat(&quot;阿猫&quot;)) ，而是在运行时我们取到这个Cat类型的元素并使用（Dog）进行转换时抛出来ClassCastException。 这显然不是我们所期望的，如果程序有潜在的错误，我们更期望在编译时被告知错误，而不是在运行时报异常。 使用泛型解决这个问题： 12345678910public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //取元素的时候不需要手动类型转换 Dog dog1 = dogs.get(0); //插入不符合预期的类型会报错 //dogs.add(new Cat(&quot;小猫老弟&quot;)); The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)&#125; 在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设置为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法将会更具有通用性。此外，如果将方法参数声明为接口，将会更加灵活。 通过这两个例子，我们可以很好理解为什么使用泛型能增强代码的复用性和类型安全性。接下来我们进一步认识java当中泛型的使用方式。 泛型基本使用泛型很好地增强了代码的灵活性和通用性。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型类将泛型使用在类上就称为泛型类。定义泛型类： 1234567891011class Point&lt;T&gt; &#123; // &lt;T&gt; 是泛型标识，代表你定义了一个类型变量 T。T代表的类型由外部决定 // 此处可以随便写标识符号，T是type的简称。 private T val ;\tpublic T getVar()&#123; return var ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; &#125; 使用泛型类：在创建泛型类对象的时候指定具体类型 12345public class Demo&#123; public static void main(String[] args) &#123; Point&lt;String&gt; point = new Point&lt;&gt;();//指定具体类型 &#125;&#125; 创建泛型类对象的时候还可以这样写： Point&lt;String&gt; point = new Point&lt;String&gt;(); 或者 Point point = new Point&lt;String&gt;();，但是一般的写法是在声明引用类型时（左边）指定泛型。具体原因学习完泛型的原理后就能理解。 也可以在类中用不同的泛型标识符指定多个泛型： 12345678910111213141516class MyEntity&lt;K,V&gt; &#123; private K key; private V value; public MyEntity()&#123;&#125; public MyEntity(K key , V val) &#123; this.key = key; this.value = val; &#125; //省略getter和setter&#125;public class TestMap &#123; public static void main(String[] args) &#123; MyEntity&lt;String,Integer&gt; map = new MyEntity&lt;&gt;(&quot;money&quot;,100); &#125;&#125; 泛型接口当将泛型使用在接口上的时候就成为泛型接口，使用方法与泛型类相同。看一个例子： 123456789101112131415161718192021interface Info&lt;T&gt;&#123; // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 &#125; class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123; // 定义泛型接口的实现类 private T var ; // 定义属性 public InfoImpl(T var)&#123; // 通过构造方法设置属性内容 this.setVar(var) ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; &#125; public class GenericsDemo&#123; public static void main(String arsg[])&#123; Info&lt;String&gt; i = new InfoImpl&lt;&gt;(&quot;汤姆&quot;) ; // 通过实现类实例化对象 System.out.println(&quot;内容：&quot; + i.getVar()) ; &#125; &#125; 泛型方法泛型方法则是在调用的时候才指定具体的类型。可以在普通类中定义泛型方法，也可以在泛型类中定义。 语法格式是在方法签名的返回值类型之前指定泛型。举一个栗子： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Test.&lt;String,Integer&gt;f1(&quot;cjp&quot;,666); //指定泛型 TypeEarse.f1(&quot;cjp&quot;,666); //不直接指定泛型 &#125; private static &lt;T,E&gt; void f1(T p1,E p2) &#123; System.out.println(&quot;T&quot; + p2); &#125;&#125; 在使用泛型方法的时候需要注意，在泛型类或者接口中带有泛型标识符方法并不一定是泛型方法。比如： public void eat(E e)&#123;...&#125; 这个方法并不是泛型方法，只是eat方法使用了泛型。 泛型的通配符与上下限在我们阅读java代码的时候会遇到这种泛型： 1default void sort(Comparator&lt;? super E&gt; c) &#123;……&#125; 在这里sort方法接收一个Comparator类型的参数c，而Comparator（比较器）是一个泛型接口，我们给比较器指定了泛型&lt;? super E&gt;,表示Comparator可以接受E以及E的父类。这样做的好处是可以更灵活地使用比较器。这也是java泛型中的一个重要的知识点，泛型的上下限。我们来看一个例子： 12345678910111213141516171819class A&#123;&#125;class B extends A &#123;&#125;// 如下两个方法不会报错public static void funA(A a) &#123; &#125;public static void funB(B b) &#123; funA(b); //父类的引用可以用来接收子类对象 &#125;// 如下funD方法会报错public static void funC(List&lt;A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;) // ... &#125; 泛型并不具备“继承性”，比如：ArrayList&lt;Object&gt; obj = new ArrayList&lt;String&gt;();❎ ，例子中func接收的List的泛型A,而传入函数的参数是List&lt;B&gt;，虽然A与B有继承关系，但是泛型却不允许这样转换（为什么？可以留着这个问题，了解了泛型的原理之后再来思考）。这也是上个例子报错的原因。 但是程序确实需要这样的需求，比如在一个集合中添加某个类或者该类的实现类（举一个具体的例子，向一个List animal中添加元素，可以是猫，狗，鸟…继承了Animal的类的对象）。直接使用泛型就会存在问题。 为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。&lt;? extends A&gt;表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。 1234567public static void funC(List&lt;? extends A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // OK : funC接收的List的泛型类型是A及其子类 // ... &#125; 在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 上限： &lt;T extends Number&gt; 1234567891011121314151617class Info&lt;T extends Number&gt;&#123; // 此处泛型可以是Number或者继承了Number的类，比如Integer,Double... private T var ; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; return this.var.toString() ; &#125;&#125;public class demo1&#123; public static void main(String args[])&#123; Info&lt;Integer&gt; i1 = new Info&lt;Integer&gt;() ; // 声明Integer的泛型对象 &#125;&#125; 下限： &lt;? super String&gt; 12345678910111213141516171819202122232425class Info&lt;T&gt;&#123; private T var ; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; return this.var.toString() ; &#125;&#125;public class GenericsDemo21&#123; public static void main(String args[])&#123; Info&lt;String&gt; i1 = new Info&lt;String&gt;() ; // 声明String的泛型对象 Info&lt;Object&gt; i2 = new Info&lt;Object&gt;() ; // 声明Object的泛型对象 i1.setVar(&quot;hello&quot;) ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; &#125; public static void fun(Info&lt;? super String&gt; temp)&#123; // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + &quot;, &quot;) ; &#125;&#125; 如果对类型的上界或者下界有多个限制，可以使用 &amp; : 1234567891011public class Client &#123; //工资低于2500元的上斑族并且站立的乘客车票打8折 public static &lt;T extends Staff &amp; Passenger&gt; void discount(T t)&#123; if(t.getSalary()&lt;2500 &amp;&amp; t.isStanding())&#123; System.out.println(&quot;恭喜你！您的车票打八折！&quot;); &#125; &#125; public static void main(String[] args) &#123; discount(new Me()); &#125;&#125; 至此我们已经基本了解了在java中使用泛型的基本语法。接下来我们继续探究java泛型的实现原理以及使用的细节。 泛型的原理与使用细节java的伪泛型 ：类型擦除java的泛型策略实际上是一种伪泛型。即在语法上支持泛型，但在编译阶段会将所有的泛型（尖括号括起来的内容）都还原成原始类型（Row Type）。比如List&lt;Integer&gt; list 在编译之后就变成：List list。这也是类型擦除（type erasure）的含义。 为什么要使用类型擦除来实现泛型呢？这样实现有什么好处？ 泛型机制是在jdk5引入的，为了兼容以前的版本，才采取了这种策略。这样使用新版的jdk写的程序编译之后与以前的代码是兼容的，就不需要重构旧的代码。 减轻 JVM 的负担，提高运行期的效率。如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作。 接下来我们来看几个具体的类型擦除的例子： 假设我们重载了这两个方法，编译器却报错： Erasure of method f1(List&lt;String&gt;) is the same as another method in type TypeEarse 即类型擦除后两个函数的签名是一致的，形参都变成 : List p1这是两个一样的函数。 1234567public class Test &#123; private void f1(List&lt;String&gt; p1) &#123; &#125; private void f1(List&lt;Integer&gt; p2) &#123; &#125;&#125; 再考虑一下下面的程序： 12345678910111213141516public class Test &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 程序中声明了一个存储Integer的ArrayList，直接调用add()方法只能存储整型变量。添加其他类型的元素： add(&quot;cjp&quot;)会报错 : The method add(Integer) in the type ArrayList&lt;Integer&gt; is not applicable for the arguments (String)。而我们如果使用反射就可以在运行过程中向集合中添加字符型类型的元素。这表明了在编译期间，ArrayList&lt;Integer&gt; list的类型是被擦除了的，还原成了原始类型：ArrayList，里面维护的Object数组，我们可以正常添加任何类型的元素。 那么类型擦除是如何进行的？ 类型擦除的原则： 消除类型参数声明，即删除&lt;&gt;及其包围的部分。 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。 为了保证类型安全，必要时插入强制类型转换代码。 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。 例子： 擦除类定义中的类型参数 - 无限制类型擦除 当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如&lt;T&gt;和&lt;?&gt;的类型参数都被替换为Object。 擦除类定义中的类型参数 - 有限制类型擦除 当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如&lt;T extends Number&gt;和&lt;? extends Number&gt;的类型参数被替换为Number，&lt;? super Number&gt;被替换为Object。（Number的父类为Object） 擦除方法定义中的类型参数 擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。 泛型的编译期检查我们前面已经知道了泛型会在编译阶段被擦除成原生类型。那么为什么当我们往List&lt;Integer&gt; list这个集合中添加其它类型的元素的时候编译器会报错呢？编译期间不是都变成了Object了吗，我添加String为什么还会报错？ 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(123); list.add(&quot;123&quot;); //编译错误 &#125; 因为编译器会在编译之前先进行对泛型类型的检查，再进行类型擦除。那么这个检查是如何进行的呢？这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。 以 ArrayList举例子，以前的写法: 1ArrayList list = new ArrayList(); 现在的写法: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况： 12ArrayList&lt;String&gt; list1 = new ArrayList(); //第一种 情况ArrayList list2 = new ArrayList&lt;String&gt;(); //第二种 情况 这样是没有错误的，不过会有个编译时警 : ArrayList is a raw type. References to generic type ArrayList&lt;E&gt; should be parameterized。在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。 因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。 举例子： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list1 = new ArrayList(); list1.add(&quot;1&quot;); //编译通过 list1.add(1); //编译错误 String str1 = list1.get(0); //返回类型就是String ArrayList list2 = new ArrayList&lt;String&gt;(); list2.add(&quot;1&quot;); //编译通过 list2.add(1); //编译通过 Object object = list2.get(0); //返回类型就是Object new ArrayList&lt;String&gt;().add(&quot;11&quot;); //编译通过 new ArrayList&lt;String&gt;().add(22); //编译错误 String str2 = new ArrayList&lt;String&gt;().get(0); //返回类型就是String &#125; &#125; 通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。 泛型的多态与桥接方法类型擦除会造成多态的冲突。例子： 12345678910111213141516171819202122class Holder&lt;T&gt; &#123; private T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123;&#125; &#125;class DateHolder extends Holder&lt;Date&gt; &#123; private Date value; @Override public Date getValue() &#123; return this.value; &#125; @Override public void setValue(Date value) &#123; this.value = value; &#125;&#125; 在这里我们定义了一个泛型接口，定义一个子类实现泛型接口，重写了接口的两个方法。我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的泛型参数&lt;T&gt;都为Date类型。所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？ 分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类接口编译之后会变成下面的样子： 12345678910class Holder &#123; public Object getValue() &#123; //... &#125; public void setValue(Object obj) &#123; //... &#125;&#125; 而实现类重写的方法： 1234567public Date getValue() &#123; return this.value; &#125; public void setValue(Date value) &#123; this.value = value; &#125; 在setValue方法中，父类方法与子类的形参的类型不同，这不是重写，而是重载。假如是重载，子类会有两个重载的setValue方法，我们测试一下： 1234567 public class TestPolymorphic &#123; public static void main(String[] args) &#123; DateHolder dateHolder = new DateHolder(); dateHolder.setValue(new Date()); dateHolder.setValue(new Object()); //编译出错：The method setValue(Date) in the type DateHolder is not applicable for the arguments (Object) &#125;&#125; 说明实现类中并没有形参为？Object的setValue()方法。这并不是重载，而是真的重写了父类的方法。由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。 于是JVM采用了一个特殊的方法，来解决泛型中多态的冲突，那就是桥接方法。 我们使用javap -c 对DateHolder进行反汇编： 12345678910111213141516171819202122232425262728293031323334353637javap -c DateHolder Compiled from &quot;DateHolder.java&quot;public class test4blog.DateHolder extends test4blog.Holder&lt;java.util.Date&gt; &#123; public test4blog.DateHolder(); Code: 0: aload_0 1: invokespecial #1 // Method test4blog/Holder.&quot;&lt;init&gt;&quot;:()V 4: return public java.util.Date getValue(); Code: 0: aload_0 1: getfield #2 // Field value:Ljava/util/Date; 4: areturn public void setValue(java.util.Date); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field value:Ljava/util/Date; 5: return public void setValue(java.lang.Object); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: aload_1 2: checkcast #3 // class java/util/Date 5: invokevirtual #4 // Method setValue:(Ljava/util/Date;)V 8: return public java.lang.Object getValue(); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: invokevirtual #5 // Method getValue:()Ljava/util/Date; 4: areturn&#125; 从反编译的结果看，子类有4方法，其中最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Override只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。 所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。 并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。 泛型疑难杂症Ｑ＆A 如何理解类型擦除之后的原始类型？ 原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。类型擦除之后代码是与没有泛型机制之前一样的（即使用Object类型来接收其它任意类型的变量）。 以List&lt;String&gt;，List&lt;Integer&gt; 为例，它们的原始类型都是List。在你声明泛型的时候，就可以根据类型类型擦除的原则确定该泛型的原始类型。 在声明泛型类的对象或者调用泛型方法时，不指定泛型编译也可以通过，这时候的对象中的相关成员类型是什么？ 注意区分一下泛型变量的类型和原始类型的概念。泛型变量的类型是指编译（类型擦除）之前，进行语法检查时使用的类型。原始类型是指泛型变量擦除去了泛型信息，最后在字节码中的类型变量的真正类型。 在泛型类或者泛型接口中，使用泛型类或者接口创建对象时不指定泛型，默认泛型类型为Object。 比如 12345public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); //创建ArrayList不指定泛型，则默认类型为Object arrayList.add(1); //可以存储任何类型的变量 arrayList.add(&quot;cjp&quot;);&#125; 在调用泛型方法时，可以指定泛型，也可以不指定泛型: 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; /**不指定泛型的时候*/ int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型 Number f = Test.add(1, 1.2); //这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number Object o = Test.add(1, &quot;asd&quot;); //这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object /**指定泛型的时候*/ int a = Test.&lt;Integer&gt;add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类 int b = Test.&lt;Integer&gt;add(1, 2.2); //编译错误，指定了Integer，不能为Float Number c = Test.&lt;Number&gt;add(1, 2.2); //指定为Number，所以可以为Integer和Float &#125; //这是一个简单的泛型方法 public static &lt;T&gt; T add(T x,T y)&#123; return y; &#125; &#125; 泛型为什么没有继承的传递关系？ 就比如前面举的例子 ArrayList&lt;Object&gt; obj = new ArrayList&lt;String&gt;();❎ 在Java中，泛型是不支持协变的。这意味着即使 ArrayList&lt;String&gt; 是 ArrayList&lt;Object&gt; 的子类型，ArrayList&lt;String&gt; 也不能赋值给 ArrayList&lt;Object&gt;。我们假设java允许这么做,再来看看这样会存在哪些问题。 &#x2F;&#x2F;TODO : 待理解 来自GPT的回答： 如果 Java 允许 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，那么可能会导致以下问题： 类型安全性问题： Java 的泛型是在编译时进行类型检查的，而不是在运行时。如果允许将 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，则编译器无法在编译时捕获到潜在的类型错误。例如，当您尝试将一个 Integer 对象添加到 ArrayList&lt;String&gt; 中时，编译器不会报错，但在运行时会抛出 ClassCastException。 破坏集合的封装性： 泛型的目的之一是增强代码的可读性和安全性，通过明确指定集合中元素的类型，可以更清晰地了解代码的意图。如果允许将 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，则破坏了集合的封装性，可能会导致代码更加难以理解和维护。 破坏泛型的不变性： 泛型具有不变性，即泛型类型参数在赋值后不能被修改。如果允许将 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，则破坏了泛型的不变性，可能导致在编译时无法检测到潜在的类型不一致问题，从而引入安全隐患。 综上所述，虽然看起来允许 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt; 可以提供一定的便利性，但这种做法会破坏泛型的安全性和封装性，可能引入类型错误和安全隐患。因此，Java 不允许这种类型的赋值。 为什么泛型类型不能实例化？ T obj = new T()❎ 因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。 如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现： 1234static &lt;T&gt; T newTclass (Class &lt; T &gt; clazz) throws InstantiationException, IllegalAccessException &#123; T obj = clazz.newInstance(); return obj;&#125; List&lt;?&gt;、List&lt;Object&gt;、List&lt;? extends Object&gt;有什么区别？ 泛型类型不同，List&lt;?&gt;使用&lt;?&gt;通配符,接收任意类型;List&lt;? extends Object&gt;的泛型参数允许接收Object及其子类。 为什么泛型不能支持基本数据类型？ 就像这个例子： List&lt;Integer&gt; list = new ArrayList&lt;&gt;() ✅ List&lt;int&gt; list = new ArrayList&lt;&gt;() ❎ 因为对泛型进行类型擦除之后成员类型是Object，而Object无法接收基本数据类型的变量：int a = 10; Object obj = a;❎ 声明和使用泛型数组存在哪些问题？ 不能使用new创建泛型数组：private T[] array = new T[10];❎Cannot create a generic array of T 。使用new创建数组是在内存开辟一块指定大小的内存，使用泛型无法确定开辟的内存大小。 类型擦除后类型为Object[ ] , 为什么不直接规定这样创建就是开辟一个指定大小的Object数组呢？ 这样规定就失去了泛型的意义。使用泛型是为了限定类型，如果规定private T[] array = new T[10]在编译之前也等价于private Object[] array = new Object[10]，那么还是不能限定数组内的元素预期的类型，取元素的时候要进行类型转换。直接规定不允许这样使用才合理。 看一下的例子： 123456List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误 Cannot create a generic array of ArrayList&lt;String&gt;，非法创建 List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误 Type mismatch: cannot convert from ArrayList&lt;?&gt;[] to List&lt;String&gt;[]，需要强转类型 List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 Type safety: Unchecked cast from ArrayList&lt;?&gt;[] to List&lt;String&gt;[] List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误 Cannot create a generic array of ArrayList&lt;String&gt;，非法创建 List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告 Type safety: The expression of type ArrayList[] needs unchecked conversion to conform to List&lt;String&gt;[] &#x2F;&#x2F;TODO : 理解为什么 静态方法中使用泛型会有什么问题？ 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。 12345678910111213141516public class UseGenericsInStatic&lt;T&gt; &#123; private T value; private static T staticValuie; //报错：Cannot make a static reference to the non-static type T //静态泛型方法 private static&lt;E&gt;Double test(E e) &#123; System.out.println(&quot;test , para: &quot; + e); return 66.6; &#125; private static Double test1(T t) &#123; //报错：Cannot make a static reference to the non-static type T System.out.println(&quot;test1 , para: &quot; + t); &#125;&#125; 泛型类在创建对象的时候指定泛型的类型，而静态成员和静态方法在类加载（对象创建之前）的时候就加载完。在静态方法或者静态变量中使用泛型无法确定这个泛型参数是何种类型。（还是不要那样想：为啥擦除后是Object，不直接规定Object。这样就没必要存在泛型了！） 参考文章： https://pdai.tech/md/java/basic/java-basic-x-generic.html https://www.cnblogs.com/54chensongxia/p/12470672.html https://stackoverflow.com/questions/36347/what-are-the-differences-between-generic-types-in-c-and-java?spm=a2c6h.12873639.article-detail.10.460a1026WugJsK https://www.cnblogs.com/strongmore/p/13945540.html","tags":["java-se"],"categories":["编程学习","java"]},{"title":"Hello World","path":"/2024/03/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"Welcome to my bolg!"}]