[{"title":"本以为10分钟解决的issue却花了一整天创建了5个分支20多次提交才解决","path":"/2024/04/11/本以为10分钟解决的issue却花了一整天创建了5个分支20多次提交才解决/","content":"记录第一次独立完整得解决dubbo社区的一个issue！这是一个good-first-issue，比较适合社区的新人。我刚看到issue描述的时候觉得很容易完成，更新相关依赖不就可以了，几分钟就搞定了吧。然而当我第一次push到仓库进行ci测试之后，才真正见识到了依赖版本冲突的可怕… issue描述https://github.com/apache/dubbo/issues/13862 component： Java Samples (apache&#x2F;dubbo-samples) description： Dubbo Samples switched the required JDK version to OpenJDK17. Dubbo Samples are entirely switched to SpringBoot3. related： https://github.com/apache/dubbo/discussions/13841 关于issue的讨论，用处不大 https://github.com/apache/dubbo-samples/pull/1057 别人提交过的pr，可以参考 https://github.com/apache/dubbo-samples/pull/1089 背景调研 apache&#x2F;dubbo-samples仓库是干什么的？ 用来演示dubbo的用途。里面有很多个子项目，分别展示了dubbo从基础到进阶的各种用法。 利用这些sample通过docker来进行dubbo的集成测试。 这些samples怎么运行？ 直接clone之后找到自己想要的某个sample，单独构建运行一个子项目。不要直接运行整个项目，太大了。 12$ cd 1-basic/dubbo-samples-spring-boot$ mvn clean package 具体描述issue是要做什么事情? 把这些sample的jdk版本更新到jdk17。之前可能用的比较老的版本。springboot3最低支持JDK 17 ，不再支持JDK 17之前的版本。 所以这些samples是为了更新springboot的版本，比如springboot3。因此也要更新jdk版本。 猜测sample里的项目大多都是基于springboot开发的，因此更新这个仓库里的所有项目需要很大的工作量。他才会让我们只负责单独的某个或几个模块。 相关的那个pr是做了什么事情？ 把相关项目的pom文件的java版本target和source改为17，springboot版本改为3.2： 解决过程 找到项目对应模块中使用到springboot的地方，将pom文件的属性改一下就行。 测试失败！！！ springcloud的服务提供者provider可以正常启动。 Dubbo Client服务调用方无法正常启动： 查看日志发现报错：在注册中心里面找不到provider。 将分支切换回master,使用原来的测试用例启动provider时，可以在nacos的控制台查看注册的服务列表： 这个服务是有注册上的。而报错的分支却没有注册服务。因此，问题出在更新代码之后provider没有办法正常在nacos注册。 springboot和springcloud是有版本的对应关系的，我刚刚只更新了springboot的版本而没有同步更新cloud的版本，导致出现了问题。 在spring的官网查看spring官网查看springboot和springcloud的版本对应关系： 查看springboot与springcloudalibaba的版本对应关系： https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB 将spring-cloud和spring-cloud-alibaba的版本更新后，全部正常。提交看看CI测试。不通过。 wc,把另一个模块给忘了。赶紧把sc-call-dubbo的模块也改了 : 以来都改了之后，手动调用是正常的。 但是测试用例却通过不了： 1234567891011121314151617181920212223242526@Test public void test() &#123; String url = String.format(&quot;http://%s:8099/dubbo/rest/test1&quot;, consumerAddress); RestTemplate restTemplate = new RestTemplate(); UserList userList = restTemplate.getForObject(url, UserList.class); assert userList != null; Assert.assertEquals(1, userList.getUsers().size()); &#125; public class UserList &#123; private List&lt;User&gt; users; public UserList() &#123; users = new ArrayList&lt;&gt;(); &#125; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; &#125; 报错信息提示：在将调用返回的结果json转为UserList的时候发生了错误。 自己在浏览器调用应用的服务拿到返回数据： 1[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Dubbo provider!&quot;&#125;] 这是一个json数组，里面包含一个对象。这个对象有两个属性 id 和 name。对应着sample里的实体类User。用UserList来接收json反序列化后的对象，即一个对象里面有一个类型为数组的属性。与返回数据不匹配啊，直接返回的是一个数组。把测试用例改一下试一试： 1234567891011@Test public void test() &#123; String url = String.format(&quot;http://%s:8099/dubbo/rest/test1&quot;, consumerAddress); RestTemplate restTemplate = new RestTemplate(); // 直接解析为 List&lt;User&gt; List&lt;User&gt; userList = restTemplate.getForObject(url, List.class); Assert.assertNotNull(userList); Assert.assertEquals(1, userList.size()); &#125; ok,本地测试通过了。但是ci测试还是不通过。 55个测试只通过了49个。 查看详细的日志，一直是这两个模块environment-keys和call-back的问题: Dubbo 3.3 &#x2F; Test Result (Java17) Dubbo 3.3 &#x2F; Test Result (Java21) integration Test (Java17, Job3) integration Test (Java21, Job3) 日志框架出现了多个绑定：https://www.slf4j.org/codes.html#multiple_bindings integration Test (Java17, Job4) integration Test (Java21, Job4) Integration Test Job3失败的原因在于：environment-keys-provider出现了多个日志实现。 Integration Test Job4失败的原因在于：callback-consumer无法连接找到provider提供的服务。 而test result失败就是因为有了这两个job的失败，在merge test result时会出现两个失败的case。 在java17和java21版本各有3个failures，所以一共有6个不通过的ci测试。 只要解决Integration Test Job3和Integration Test Job4即可。 着手解决job3: 123456789101112131415161718192021SLF4J(W): Class path contains multiple SLF4J providers.SLF4J(W): Found provider [org.apache.logging.slf4j.SLF4JServiceProvider@3cd1f1c8]SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@3a4afd8d]SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J(I): Actual provider is of type [org.apache.logging.slf4j.SLF4JServiceProvider@3cd1f1c8]Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError\tat org.apache.dubbo.samples.environment.keys.provider.ProviderApplication.main(ProviderApplication.java:28)Caused by: org.apache.logging.log4j.LoggingException: log4j-slf4j2-impl cannot be present with log4j-to-slf4j\tat org.apache.logging.slf4j.Log4jLoggerFactory.validateContext(Log4jLoggerFactory.java:70)\tat org.apache.logging.slf4j.Log4jLoggerFactory.newLogger(Log4jLoggerFactory.java:50)\tat org.apache.logging.slf4j.Log4jLoggerFactory.newLogger(Log4jLoggerFactory.java:33)\tat org.apache.logging.log4j.spi.AbstractLoggerAdapter.getLogger(AbstractLoggerAdapter.java:53)\tat org.apache.logging.slf4j.Log4jLoggerFactory.getLogger(Log4jLoggerFactory.java:33)\tat org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:422)\tat org.apache.commons.logging.LogAdapter$Slf4jAdapter.createLocationAwareLog(LogAdapter.java:121)\tat org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:95)\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67)\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59)\tat org.springframework.boot.SpringApplication.&lt;clinit&gt;(SpringApplication.java:202)\t... 1 more 在应用程序中，发现了多个 SLF4J 的提供者， org.apache.logging.slf4j.SLF4JServiceProvider@3cd1f1c8 ch.qos.logback.classic.spi.LogbackServiceProvider@3a4afd8d 这只是警告，它也自己选了ch.qos.logback.classic.spi.LogbackServiceProvider@3a4afd8d这个实现。 在错误消息指出了 log4j-slf4j2-impl 和 log4j-to-slf4j 不能同时存在。这是因为这两个依赖提供了不同的方式来桥接 Log4j 和 SLF4J，而它们之间可能会发生冲突。解决这个问题的方法通常是排除其中一个冲突的依赖，以确保只有一个 SLF4J 的实现被加载。 idea里打开dubbo.samples.environment.keys.provider模块，在maven插件里搜索这两个依赖： 发现log4j-to-slf4j是在spring-boot-starter里的spring-boot-logging引入的 而log4j-slf4j2-impl则是在spring-boot-starter-log4j2里引入的。 删除它们中的任意一个依赖就可以了。 ps : 我当时思路还没这么清晰，在引入spring-boot-starter的时候把spring-boot-logging排除掉： (其实在这里还有一个问题，在dubbo.samples.environment.keys.provider的父模块里进行依赖管理(标签)的时候，已经把这个spring-boot-starter-logging给排除了，子模块直接引入spring-boot-starter的时候为什么还是把它引进来了？) 123456789101112&lt;!-- spring starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 还顺手把spring-boot-starter-log4j2依赖给删了，虽然没有了警告并且ci测试的job3也通过了，但是我好像把这个模块的日志系统搞得不健全了……(没事，以后再改) 奈斯奈斯！！！job3解决！！！ 接下来解决job4: 1234567891011121314---------------------------------------------------------- dubbo-samples-callback log: callback-consumer.log----------------------------------------------------------Start at: 2024-04-09 12:34:51Waiting ports before run test ..checking tcp ports: callback-provider:2181;callback-provider:20880;, start at: 0, timeout: 180checking tcp port [callback-provider:2181] ...telnet: Unable to connect to remote host: Connection refusedTrying 192.168.48.2...telnet: Unable to connect to remote host: Connection refusedTrying 192.168.48.2...Trying 192.168.48.2...Connected to callback-provider.Escape character is &#x27;^]&#x27;. callback-consumer找不到provider,连接超时了哇。猜测是provider无法正常在Zookeeper注册。 运行一下测试用例,发现了一个错误信息： 12312:59:33.141 [ZooKeeper Server Starter] INFO org.apache.zookeeper.audit.ZKAuditProvider -- ZooKeeper audit is disabled.12:59:33.688 |-ERROR [main] org.apache.dubbo.common.Version:111 -| [DUBBO] Inconsistent version 3.2.3 found in dubbo-zookeeper-curator5-spring-boot-starter from file:/D:/devTool/Maven/maven-repository/org/apache/dubbo/dubbo-zookeeper-curator5-spring-boot-starter/3.2.3/dubbo-zookeeper-curator5-spring-boot-starter-3.2.3.jar!/META-INF/versions/dubbo-zookeeper-curator5-spring-boot-starter, expected dubbo-common version is 3.3.0-beta.1, dubbo version: 3.3.0-beta.1, current host: 169.254.123.149, error code: 0-12. This may be caused by , go to https://dubbo.apache.org/faq/0/12 to find instructions. 12:59:33.692 |-ERROR [main] org.apache.dubbo.common.Version:111 -| [DUBBO] Inconsistent git build commit id 8256e5646f5589bced5c458db586cae70cd16e2f found in dubbo-zookeeper-curator5-spring-boot-starter from file:/D:/devTool/Maven/maven-repository/org/apache/dubbo/dubbo-zookeeper-curator5-spring-boot-starter/3.2.3/dubbo-zookeeper-curator5-spring-boot-starter-3.2.3.jar!/META-INF/versions/dubbo-zookeeper-curator5-spring-boot-starter, expected dubbo-common version is 0c9d5e2f7383760018db38877863d6fc16fd6689, dubbo version: 3.3.0-beta.1, current host: 169.254.123.149, error code: 0-12. This may be caused by , go to https://dubbo.apache.org/faq/0/12 to find instructions. 这个错误消息表明在项目中发现了不一致的 Dubbo 版本信息。Dubbo 在运行时发现了一个与预期版本不一致的组件，这可能导致一些问题。在日志中，Dubbo 发现了一个名称为 dubbo-zookeeper-curator5-spring-boot-starter 的组件，其版本为 3.2.3，但是 Dubbo 期望的版本是 3.3.0-beta.1。 soga，原来是starter的版本跟dubbo版本冲突了！！ 那就把dubbo-zookeeper-curator5-spring-boot-starter改为3.3.0-beta.1 完美解决！！！ 总结梳理一遍流程： springcloud模块： 更新相关依赖 更新test case 更新test-case configuration environment-keys的consumer和provider模块： 删除spring-boot-starter-log4j2依赖 (这一步是不应该删的) 在spring-boot-starter里面排除logging callback模块: 修改dubbo-zookeeper-curator5-spring-boot-starter版本 修改日志依赖(这一步也是不应该删的) 可是我刚刚去测试了一遍如果不删除spring-boot-starter-log4j2的依赖，callback和environment-keys模块还是会有那个警告… 但是在maven的依赖树里查找就不存在 log4j-slf4j2-impl 和 log4j-to-slf4j 同时存在的问题。 总结一下这次解决issue的收获： 做事情要专注并且持续地做完。不能像上次解决issue的时候三天打鱼两天晒网，断断续续地，最后没有完成任务。 看日志要有耐心并且仔细，快速定位到问题。不要日志随便一扫就盲目靠感觉去试，那样子成功了只是运气好，一定要学会好好分析问题。 需要学习一下GitHub ci的相关知识，这样有助于更好理解ci测试failure是为什么 需要重新复习java的日志库，日志系统和日志门面又忘了。刚好这次遇到了日志框架冲突的问题，可以结合这个例子加深一下印象。","tags":["dubbo"],"categories":["编程学习","参与开源社区"]},{"title":"深入理解java泛型","path":"/2024/03/27/深入理解java泛型/","content":"认识java的泛型机制泛型机制（Generics）是一种编程语言特性。允许在编写代码时使用参数化类型。它允许开发者在设计类、接口和方法时使用类型参数，这些类型参数可以在使用时被实际的类型替换。泛型机制的主要目的是增加代码的灵活性、可重用性和类型安全性。 我们通过一个简单的例子认识java的泛型以及感受一下泛型的好处： 假设我们需要实现一个加法功能，支持多种数据类型进行相加。 我们可以使用重载写多个add方法： 1234567891011121314private static int add(int a, int b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static float add(float a, float b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static double add(double a, double b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125; 这样做每种类型都需要重载一个add方法；而通过泛型，我们可以复用为一个方法： 12345//这里定义了一个泛型方法，返回值类型为double,方法接收的参数类型为Number类型及其子类。private static &lt;T extends Number&gt; double add(T a, T b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue();&#125; 再看这个例子，向一个集合dogs中添加3个Dog对象： 123456789101112131415161718192021222324252627class Dog &#123; private String name; Dog()&#123;&#125; Dog(String name) &#123; this.name = name; &#125;&#125;class Cat &#123; private String name; Cat()&#123;&#125; Cat(String name) &#123; this.name = name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; //传统写法 List dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //手动类型转换 Dog dog1 = (Dog)dogs.get(0); &#125;&#125; 这样写存在什么问题呢？ 需要手动进行类型转换：因为我们在声明List的时候并没有指定集合当中元素的类型，ArrayList只是维护了一个Object引用的数组。我们接收这个对象就需要进行一次类型转换：Dog dog1 = (Dog)dogs.get(0); 进行强制类型转换效率较低，并且可能会抛出类转换异常ClassCastException。而这个异常我们无法在编译中发现，只能在运行时才能发现，存在安全隐患。 不能对集合中元素的类型进行约束：在我们的需求中是往dogs中添加Dog对象。但是如果我向集合中添加其他类型的元素编译时却不会有任何错误提示：dogs.add(new Cat(&quot;阿猫&quot;)) ，而是在运行时我们取到这个Cat类型的元素并使用（Dog）进行转换时抛出来ClassCastException。 这显然不是我们所期望的，如果程序有潜在的错误，我们更期望在编译时被告知错误，而不是在运行时报异常。 使用泛型解决这个问题： 12345678910public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //取元素的时候不需要手动类型转换 Dog dog1 = dogs.get(0); //插入不符合预期的类型会报错 //dogs.add(new Cat(&quot;小猫老弟&quot;)); The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)&#125; 在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设置为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法将会更具有通用性。此外，如果将方法参数声明为接口，将会更加灵活。 通过这两个例子，我们可以很好理解为什么使用泛型能增强代码的复用性和类型安全性。接下来我们进一步认识java当中泛型的使用方式。 泛型基本使用泛型很好地增强了代码的灵活性和通用性。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型类将泛型使用在类上就称为泛型类。定义泛型类： 1234567891011class Point&lt;T&gt; &#123; // &lt;T&gt; 是泛型标识，代表你定义了一个类型变量 T。T代表的类型由外部决定 // 此处可以随便写标识符号，T是type的简称。 private T val ;\tpublic T getVar()&#123; return var ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; &#125; 使用泛型类：在创建泛型类对象的时候指定具体类型 12345public class Demo&#123; public static void main(String[] args) &#123; Point&lt;String&gt; point = new Point&lt;&gt;();//指定具体类型 &#125;&#125; 创建泛型类对象的时候还可以这样写： Point&lt;String&gt; point = new Point&lt;String&gt;(); 或者 Point point = new Point&lt;String&gt;();，但是一般的写法是在声明引用类型时（左边）指定泛型。具体原因学习完泛型的原理后就能理解。 也可以在类中用不同的泛型标识符指定多个泛型： 12345678910111213141516class MyEntity&lt;K,V&gt; &#123; private K key; private V value; public MyEntity()&#123;&#125; public MyEntity(K key , V val) &#123; this.key = key; this.value = val; &#125; //省略getter和setter&#125;public class TestMap &#123; public static void main(String[] args) &#123; MyEntity&lt;String,Integer&gt; map = new MyEntity&lt;&gt;(&quot;money&quot;,100); &#125;&#125; 泛型接口当将泛型使用在接口上的时候就成为泛型接口，使用方法与泛型类相同。看一个例子： 123456789101112131415161718192021interface Info&lt;T&gt;&#123; // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 &#125; class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123; // 定义泛型接口的实现类 private T var ; // 定义属性 public InfoImpl(T var)&#123; // 通过构造方法设置属性内容 this.setVar(var) ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; &#125; public class GenericsDemo&#123; public static void main(String arsg[])&#123; Info&lt;String&gt; i = new InfoImpl&lt;&gt;(&quot;汤姆&quot;) ; // 通过实现类实例化对象 System.out.println(&quot;内容：&quot; + i.getVar()) ; &#125; &#125; 泛型方法泛型方法则是在调用的时候才指定具体的类型。可以在普通类中定义泛型方法，也可以在泛型类中定义。 语法格式是在方法签名的返回值类型之前指定泛型。举一个栗子： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Test.&lt;String,Integer&gt;f1(&quot;cjp&quot;,666); //指定泛型 TypeEarse.f1(&quot;cjp&quot;,666); //不直接指定泛型 &#125; private static &lt;T,E&gt; void f1(T p1,E p2) &#123; System.out.println(&quot;T&quot; + p2); &#125;&#125; 在使用泛型方法的时候需要注意，在泛型类或者接口中带有泛型标识符方法并不一定是泛型方法。比如： public void eat(E e)&#123;...&#125; 这个方法并不是泛型方法，只是eat方法使用了泛型。 泛型的通配符与上下限在我们阅读java代码的时候会遇到这种泛型： 1default void sort(Comparator&lt;? super E&gt; c) &#123;……&#125; 在这里sort方法接收一个Comparator类型的参数c，而Comparator（比较器）是一个泛型接口，我们给比较器指定了泛型&lt;? super E&gt;,表示Comparator可以接受E以及E的父类。这样做的好处是可以更灵活地使用比较器。这也是java泛型中的一个重要的知识点，泛型的上下限。我们来看一个例子： 12345678910111213141516171819class A&#123;&#125;class B extends A &#123;&#125;// 如下两个方法不会报错public static void funA(A a) &#123; &#125;public static void funB(B b) &#123; funA(b); //父类的引用可以用来接收子类对象 &#125;// 如下funD方法会报错public static void funC(List&lt;A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;) // ... &#125; 泛型并不具备“继承性”，比如：ArrayList&lt;Object&gt; obj = new ArrayList&lt;String&gt;();❎ ，例子中func接收的List的泛型A,而传入函数的参数是List&lt;B&gt;，虽然A与B有继承关系，但是泛型却不允许这样转换（为什么？可以留着这个问题，了解了泛型的原理之后再来思考）。这也是上个例子报错的原因。 但是程序确实需要这样的需求，比如在一个集合中添加某个类或者该类的实现类（举一个具体的例子，向一个List animal中添加元素，可以是猫，狗，鸟…继承了Animal的类的对象）。直接使用泛型就会存在问题。 为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。&lt;? extends A&gt;表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。 1234567public static void funC(List&lt;? extends A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // OK : funC接收的List的泛型类型是A及其子类 // ... &#125; 在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 上限： &lt;T extends Number&gt; 1234567891011121314151617class Info&lt;T extends Number&gt;&#123; // 此处泛型可以是Number或者继承了Number的类，比如Integer,Double... private T var ; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; return this.var.toString() ; &#125;&#125;public class demo1&#123; public static void main(String args[])&#123; Info&lt;Integer&gt; i1 = new Info&lt;Integer&gt;() ; // 声明Integer的泛型对象 &#125;&#125; 下限： &lt;? super String&gt; 12345678910111213141516171819202122232425class Info&lt;T&gt;&#123; private T var ; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; return this.var.toString() ; &#125;&#125;public class GenericsDemo21&#123; public static void main(String args[])&#123; Info&lt;String&gt; i1 = new Info&lt;String&gt;() ; // 声明String的泛型对象 Info&lt;Object&gt; i2 = new Info&lt;Object&gt;() ; // 声明Object的泛型对象 i1.setVar(&quot;hello&quot;) ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; &#125; public static void fun(Info&lt;? super String&gt; temp)&#123; // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + &quot;, &quot;) ; &#125;&#125; 如果对类型的上界或者下界有多个限制，可以使用 &amp; : 1234567891011public class Client &#123; //工资低于2500元的上斑族并且站立的乘客车票打8折 public static &lt;T extends Staff &amp; Passenger&gt; void discount(T t)&#123; if(t.getSalary()&lt;2500 &amp;&amp; t.isStanding())&#123; System.out.println(&quot;恭喜你！您的车票打八折！&quot;); &#125; &#125; public static void main(String[] args) &#123; discount(new Me()); &#125;&#125; 至此我们已经基本了解了在java中使用泛型的基本语法。接下来我们继续探究java泛型的实现原理以及使用的细节。 泛型的原理与使用细节java的伪泛型 ：类型擦除java的泛型策略实际上是一种伪泛型。即在语法上支持泛型，但在编译阶段会将所有的泛型（尖括号括起来的内容）都还原成原始类型（Row Type）。比如List&lt;Integer&gt; list 在编译之后就变成：List list。这也是类型擦除（type erasure）的含义。 为什么要使用类型擦除来实现泛型呢？这样实现有什么好处？ 泛型机制是在jdk5引入的，为了兼容以前的版本，才采取了这种策略。这样使用新版的jdk写的程序编译之后与以前的代码是兼容的，就不需要重构旧的代码。 减轻 JVM 的负担，提高运行期的效率。如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作。 接下来我们来看几个具体的类型擦除的例子： 假设我们重载了这两个方法，编译器却报错： Erasure of method f1(List&lt;String&gt;) is the same as another method in type TypeEarse 即类型擦除后两个函数的签名是一致的，形参都变成 : List p1这是两个一样的函数。 1234567public class Test &#123; private void f1(List&lt;String&gt; p1) &#123; &#125; private void f1(List&lt;Integer&gt; p2) &#123; &#125;&#125; 再考虑一下下面的程序： 12345678910111213141516public class Test &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 程序中声明了一个存储Integer的ArrayList，直接调用add()方法只能存储整型变量。添加其他类型的元素： add(&quot;cjp&quot;)会报错 : The method add(Integer) in the type ArrayList&lt;Integer&gt; is not applicable for the arguments (String)。而我们如果使用反射就可以在运行过程中向集合中添加字符型类型的元素。这表明了在编译期间，ArrayList&lt;Integer&gt; list的类型是被擦除了的，还原成了原始类型：ArrayList，里面维护的Object数组，我们可以正常添加任何类型的元素。 那么类型擦除是如何进行的？ 类型擦除的原则： 消除类型参数声明，即删除&lt;&gt;及其包围的部分。 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。 为了保证类型安全，必要时插入强制类型转换代码。 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。 例子： 擦除类定义中的类型参数 - 无限制类型擦除 当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如&lt;T&gt;和&lt;?&gt;的类型参数都被替换为Object。 擦除类定义中的类型参数 - 有限制类型擦除 当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如&lt;T extends Number&gt;和&lt;? extends Number&gt;的类型参数被替换为Number，&lt;? super Number&gt;被替换为Object。（Number的父类为Object） 擦除方法定义中的类型参数 擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。 泛型的编译期检查我们前面已经知道了泛型会在编译阶段被擦除成原生类型。那么为什么当我们往List&lt;Integer&gt; list这个集合中添加其它类型的元素的时候编译器会报错呢？编译期间不是都变成了Object了吗，我添加String为什么还会报错？ 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(123); list.add(&quot;123&quot;); //编译错误 &#125; 因为编译器会在编译之前先进行对泛型类型的检查，再进行类型擦除。那么这个检查是如何进行的呢？这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。 以 ArrayList举例子，以前的写法: 1ArrayList list = new ArrayList(); 现在的写法: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况： 12ArrayList&lt;String&gt; list1 = new ArrayList(); //第一种 情况ArrayList list2 = new ArrayList&lt;String&gt;(); //第二种 情况 这样是没有错误的，不过会有个编译时警 : ArrayList is a raw type. References to generic type ArrayList&lt;E&gt; should be parameterized。在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。 因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。 举例子： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list1 = new ArrayList(); list1.add(&quot;1&quot;); //编译通过 list1.add(1); //编译错误 String str1 = list1.get(0); //返回类型就是String ArrayList list2 = new ArrayList&lt;String&gt;(); list2.add(&quot;1&quot;); //编译通过 list2.add(1); //编译通过 Object object = list2.get(0); //返回类型就是Object new ArrayList&lt;String&gt;().add(&quot;11&quot;); //编译通过 new ArrayList&lt;String&gt;().add(22); //编译错误 String str2 = new ArrayList&lt;String&gt;().get(0); //返回类型就是String &#125; &#125; 通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。 泛型的多态与桥接方法类型擦除会造成多态的冲突。例子： 12345678910111213141516171819202122class Holder&lt;T&gt; &#123; private T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123;&#125; &#125;class DateHolder extends Holder&lt;Date&gt; &#123; private Date value; @Override public Date getValue() &#123; return this.value; &#125; @Override public void setValue(Date value) &#123; this.value = value; &#125;&#125; 在这里我们定义了一个泛型接口，定义一个子类实现泛型接口，重写了接口的两个方法。我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的泛型参数&lt;T&gt;都为Date类型。所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？ 分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类接口编译之后会变成下面的样子： 12345678910class Holder &#123; public Object getValue() &#123; //... &#125; public void setValue(Object obj) &#123; //... &#125;&#125; 而实现类重写的方法： 1234567public Date getValue() &#123; return this.value; &#125; public void setValue(Date value) &#123; this.value = value; &#125; 在setValue方法中，父类方法与子类的形参的类型不同，这不是重写，而是重载。假如是重载，子类会有两个重载的setValue方法，我们测试一下： 1234567 public class TestPolymorphic &#123; public static void main(String[] args) &#123; DateHolder dateHolder = new DateHolder(); dateHolder.setValue(new Date()); dateHolder.setValue(new Object()); //编译出错：The method setValue(Date) in the type DateHolder is not applicable for the arguments (Object) &#125;&#125; 说明实现类中并没有形参为？Object的setValue()方法。这并不是重载，而是真的重写了父类的方法。由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。 于是JVM采用了一个特殊的方法，来解决泛型中多态的冲突，那就是桥接方法。 我们使用javap -c 对DateHolder进行反汇编： 12345678910111213141516171819202122232425262728293031323334353637javap -c DateHolder Compiled from &quot;DateHolder.java&quot;public class test4blog.DateHolder extends test4blog.Holder&lt;java.util.Date&gt; &#123; public test4blog.DateHolder(); Code: 0: aload_0 1: invokespecial #1 // Method test4blog/Holder.&quot;&lt;init&gt;&quot;:()V 4: return public java.util.Date getValue(); Code: 0: aload_0 1: getfield #2 // Field value:Ljava/util/Date; 4: areturn public void setValue(java.util.Date); Code: 0: aload_0 1: aload_1 2: putfield #2 // Field value:Ljava/util/Date; 5: return public void setValue(java.lang.Object); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: aload_1 2: checkcast #3 // class java/util/Date 5: invokevirtual #4 // Method setValue:(Ljava/util/Date;)V 8: return public java.lang.Object getValue(); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: invokevirtual #5 // Method getValue:()Ljava/util/Date; 4: areturn&#125; 从反编译的结果看，子类有4方法，其中最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Override只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。 所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。 并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。 泛型疑难杂症Ｑ＆A 如何理解类型擦除之后的原始类型？ 原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。类型擦除之后代码是与没有泛型机制之前一样的（即使用Object类型来接收其它任意类型的变量）。 以List&lt;String&gt;，List&lt;Integer&gt; 为例，它们的原始类型都是List。在你声明泛型的时候，就可以根据类型类型擦除的原则确定该泛型的原始类型。 在声明泛型类的对象或者调用泛型方法时，不指定泛型编译也可以通过，这时候的对象中的相关成员类型是什么？ 注意区分一下泛型变量的类型和原始类型的概念。泛型变量的类型是指编译（类型擦除）之前，进行语法检查时使用的类型。原始类型是指泛型变量擦除去了泛型信息，最后在字节码中的类型变量的真正类型。 在泛型类或者泛型接口中，使用泛型类或者接口创建对象时不指定泛型，默认泛型类型为Object。 比如 12345public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); //创建ArrayList不指定泛型，则默认类型为Object arrayList.add(1); //可以存储任何类型的变量 arrayList.add(&quot;cjp&quot;);&#125; 在调用泛型方法时，可以指定泛型，也可以不指定泛型: 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; /**不指定泛型的时候*/ int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型 Number f = Test.add(1, 1.2); //这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number Object o = Test.add(1, &quot;asd&quot;); //这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object /**指定泛型的时候*/ int a = Test.&lt;Integer&gt;add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类 int b = Test.&lt;Integer&gt;add(1, 2.2); //编译错误，指定了Integer，不能为Float Number c = Test.&lt;Number&gt;add(1, 2.2); //指定为Number，所以可以为Integer和Float &#125; //这是一个简单的泛型方法 public static &lt;T&gt; T add(T x,T y)&#123; return y; &#125; &#125; 泛型为什么没有继承的传递关系？ 就比如前面举的例子 ArrayList&lt;Object&gt; obj = new ArrayList&lt;String&gt;();❎ 在Java中，泛型是不支持协变的。这意味着即使 ArrayList&lt;String&gt; 是 ArrayList&lt;Object&gt; 的子类型，ArrayList&lt;String&gt; 也不能赋值给 ArrayList&lt;Object&gt;。我们假设java允许这么做,再来看看这样会存在哪些问题。 &#x2F;&#x2F;TODO : 待理解 来自GPT的回答： 如果 Java 允许 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，那么可能会导致以下问题： 类型安全性问题： Java 的泛型是在编译时进行类型检查的，而不是在运行时。如果允许将 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，则编译器无法在编译时捕获到潜在的类型错误。例如，当您尝试将一个 Integer 对象添加到 ArrayList&lt;String&gt; 中时，编译器不会报错，但在运行时会抛出 ClassCastException。 破坏集合的封装性： 泛型的目的之一是增强代码的可读性和安全性，通过明确指定集合中元素的类型，可以更清晰地了解代码的意图。如果允许将 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，则破坏了集合的封装性，可能会导致代码更加难以理解和维护。 破坏泛型的不变性： 泛型具有不变性，即泛型类型参数在赋值后不能被修改。如果允许将 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt;，则破坏了泛型的不变性，可能导致在编译时无法检测到潜在的类型不一致问题，从而引入安全隐患。 综上所述，虽然看起来允许 ArrayList&lt;String&gt; 赋值给 ArrayList&lt;Object&gt; 可以提供一定的便利性，但这种做法会破坏泛型的安全性和封装性，可能引入类型错误和安全隐患。因此，Java 不允许这种类型的赋值。 为什么泛型类型不能实例化？ T obj = new T()❎ 因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。 如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现： 1234static &lt;T&gt; T newTclass (Class &lt; T &gt; clazz) throws InstantiationException, IllegalAccessException &#123; T obj = clazz.newInstance(); return obj;&#125; List&lt;?&gt;、List&lt;Object&gt;、List&lt;? extends Object&gt;有什么区别？ 泛型类型不同，List&lt;?&gt;使用&lt;?&gt;通配符,接收任意类型;List&lt;? extends Object&gt;的泛型参数允许接收Object及其子类。 为什么泛型不能支持基本数据类型？ 就像这个例子： List&lt;Integer&gt; list = new ArrayList&lt;&gt;() ✅ List&lt;int&gt; list = new ArrayList&lt;&gt;() ❎ 因为对泛型进行类型擦除之后成员类型是Object，而Object无法接收基本数据类型的变量：int a = 10; Object obj = a;❎ 声明和使用泛型数组存在哪些问题？ 不能使用new创建泛型数组：private T[] array = new T[10];❎Cannot create a generic array of T 。使用new创建数组是在内存开辟一块指定大小的内存，使用泛型无法确定开辟的内存大小。 类型擦除后类型为Object[ ] , 为什么不直接规定这样创建就是开辟一个指定大小的Object数组呢？ 这样规定就失去了泛型的意义。使用泛型是为了限定类型，如果规定private T[] array = new T[10]在编译之前也等价于private Object[] array = new Object[10]，那么还是不能限定数组内的元素预期的类型，取元素的时候要进行类型转换。直接规定不允许这样使用才合理。 看一下的例子： 123456List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误 Cannot create a generic array of ArrayList&lt;String&gt;，非法创建 List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误 Type mismatch: cannot convert from ArrayList&lt;?&gt;[] to List&lt;String&gt;[]，需要强转类型 List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 Type safety: Unchecked cast from ArrayList&lt;?&gt;[] to List&lt;String&gt;[] List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误 Cannot create a generic array of ArrayList&lt;String&gt;，非法创建 List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告 Type safety: The expression of type ArrayList[] needs unchecked conversion to conform to List&lt;String&gt;[] &#x2F;&#x2F;TODO : 理解为什么 静态方法中使用泛型会有什么问题？ 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。 12345678910111213141516public class UseGenericsInStatic&lt;T&gt; &#123; private T value; private static T staticValuie; //报错：Cannot make a static reference to the non-static type T //静态泛型方法 private static&lt;E&gt;Double test(E e) &#123; System.out.println(&quot;test , para: &quot; + e); return 66.6; &#125; private static Double test1(T t) &#123; //报错：Cannot make a static reference to the non-static type T System.out.println(&quot;test1 , para: &quot; + t); &#125;&#125; 泛型类在创建对象的时候指定泛型的类型，而静态成员和静态方法在类加载（对象创建之前）的时候就加载完。在静态方法或者静态变量中使用泛型无法确定这个泛型参数是何种类型。（还是不要那样想：为啥擦除后是Object，不直接规定Object。这样就没必要存在泛型了！） 参考文章： https://pdai.tech/md/java/basic/java-basic-x-generic.html https://www.cnblogs.com/54chensongxia/p/12470672.html https://stackoverflow.com/questions/36347/what-are-the-differences-between-generic-types-in-c-and-java?spm=a2c6h.12873639.article-detail.10.460a1026WugJsK https://www.cnblogs.com/strongmore/p/13945540.html","tags":["java-se"],"categories":["编程学习","java"]},{"title":"Hello World","path":"/2024/03/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"Welcome to my bolg!"}]