[{"title":"深入理解java泛型","path":"/2024/03/27/深入理解java泛型/","content":"认识java的泛型机制泛型机制（Generics）是一种编程语言特性。允许在编写代码时使用参数化类型。它允许开发者在设计类、接口和方法时使用类型参数，这些类型参数可以在使用时被实际的类型替换。泛型机制的主要目的是增加代码的灵活性、可重用性和类型安全性。 我们通过一个简单的例子认识java的泛型以及感受一下泛型的好处： 假设我们需要实现一个加法功能，支持多种数据类型进行相加。 我们可以使用重载写多个add方法： 1234567891011121314private static int add(int a, int b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static float add(float a, float b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static double add(double a, double b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125; 这样做每种类型都需要重载一个add方法；而通过泛型，我们可以复用为一个方法： 12345//这里定义了一个泛型方法，返回值类型为double,方法接收的参数类型为Number类型及其子类。private static &lt;T extends Number&gt; double add(T a, T b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue();&#125; 再看这个例子，向一个集合dogs中添加3个Dog对象： 123456789101112131415161718192021222324252627class Dog &#123; private String name; Dog()&#123;&#125; Dog(String name) &#123; this.name = name; &#125;&#125;class Cat &#123; private String name; Cat()&#123;&#125; Cat(String name) &#123; this.name = name; &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; //传统写法 List dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //手动类型转换 Dog dog1 = (Dog)dogs.get(0); &#125;&#125; 这样写存在什么问题呢？ 需要手动进行类型转换：因为我们在声明List的时候并没有指定集合当中元素的类型，ArrayList只是维护了一个Object引用的数组。我们接收这个对象就需要进行一次类型转换：Dog dog1 = (Dog)dogs.get(0); 进行强制类型转换效率较低，并且可能会抛出类转换异常ClassCastException。而这个异常我们无法在编译中发现，只能在运行时才能发现，存在安全隐患。 不能对集合中元素的类型进行约束：在我们的需求中是往dogs中添加Dog对象。但是如果我向集合中添加其他类型的元素编译时却不会有任何错误提示：dogs.add(new Cat(&quot;阿猫&quot;)) ，而是在运行时我们取到这个Cat类型的元素并使用（Dog）进行转换时抛出来ClassCastException。 这显然不是我们所期望的，如果程序有潜在的错误，我们更期望在编译时被告知错误，而不是在运行时报异常。 使用泛型解决这个问题： 12345678910public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList(); dogs.add(new Dog(&quot;大黄&quot;)); dogs.add(new Dog(&quot;大白&quot;)); dogs.add(new Dog(&quot;小黑&quot;)); //取元素的时候不需要手动类型转换 Dog dog1 = dogs.get(0); //插入不符合预期的类型会报错 //dogs.add(new Cat(&quot;小猫老弟&quot;)); The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)&#125; 在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设置为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法将会更具有通用性。此外，如果将方法参数声明为接口，将会更加灵活。 通过这两个例子，我们可以很好理解为什么使用泛型能增强代码的复用性和类型安全性。接下来我们进一步认识java当中泛型的使用方式。 泛型基本使用泛型很好地增强了代码的灵活性和通用性。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 泛型类将泛型使用在类上就称为泛型类。定义泛型类： 1234567891011class Point&lt;T&gt; &#123; // &lt;T&gt; 是泛型标识，代表你定义了一个类型变量 T。T代表的类型由外部决定 // 此处可以随便写标识符号，T是type的简称。 private T val ;\tpublic T getVar()&#123; return var ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; &#125; 使用泛型类：在创建泛型类对象的时候指定具体类型 12345public class Demo&#123; public static void main(String[] args) &#123; Point&lt;String&gt; point = new Point&lt;&gt;();//指定具体类型 &#125;&#125; 创建泛型类对象的时候还可以这样写： Point&lt;String&gt; point = new Point&lt;String&gt;(); 或者 Point point = new Point&lt;String&gt;();，但是一般的写法是在声明引用类型时（左边）指定泛型。具体原因学习完泛型的原理后就能理解。 也可以在类中用不同的泛型标识符指定多个泛型： 12345678910111213141516class MyEntity&lt;K,V&gt; &#123; private K key; private V value; public MyEntity()&#123;&#125; public MyEntity(K key , V val) &#123; this.key = key; this.value = val; &#125; //省略getter和setter&#125;public class TestMap &#123; public static void main(String[] args) &#123; MyEntity&lt;String,Integer&gt; map = new MyEntity&lt;&gt;(&quot;money&quot;,100); &#125;&#125; 泛型接口当将泛型使用在接口上的时候就成为泛型接口，使用方法与泛型类相同。看一个例子： 123456789101112131415161718192021interface Info&lt;T&gt;&#123; // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 &#125; class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123; // 定义泛型接口的实现类 private T var ; // 定义属性 public InfoImpl(T var)&#123; // 通过构造方法设置属性内容 this.setVar(var) ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; &#125; public class GenericsDemo&#123; public static void main(String arsg[])&#123; Info&lt;String&gt; i = new InfoImpl&lt;&gt;(&quot;汤姆&quot;) ; // 通过实现类实例化对象 System.out.println(&quot;内容：&quot; + i.getVar()) ; &#125; &#125; 泛型方法泛型方法则是在调用的时候才指定具体的类型。可以在普通类中定义泛型方法，也可以在泛型类中定义。 语法格式是在方法签名的返回值类型之前指定泛型。举一个栗子： 1234567891011public class Test &#123; public static void main(String[] args) &#123; Test.&lt;String,Integer&gt;f1(&quot;cjp&quot;,666); //指定泛型 TypeEarse.f1(&quot;cjp&quot;,666); //不直接指定泛型 &#125; private static &lt;T,E&gt; void f1(T p1,E p2) &#123; System.out.println(&quot;T&quot; + p2); &#125;&#125; 在使用泛型方法的时候需要注意，在泛型类或者接口中带有泛型标识符方法并不一定是泛型方法。比如： public void eat(E e)&#123;...&#125; 这个方法并不是泛型方法，只是eat方法使用了泛型。 泛型的通配符与上下限在我们阅读java代码的时候会遇到这种泛型： 1default void sort(Comparator&lt;? super E&gt; c) &#123;……&#125; 在这里sort方法接收一个Comparator类型的参数c，而Comparator（比较器）是一个泛型接口，我们给比较器指定了泛型&lt;? super E&gt;,表示Comparator可以接受E以及E的父类。这样做的好处是可以更灵活地使用比较器。这也是java泛型中的一个重要的知识点，泛型的上下限。我们来看一个例子： 12345678910111213141516171819class A&#123;&#125;class B extends A &#123;&#125;// 如下两个方法不会报错public static void funA(A a) &#123; &#125;public static void funB(B b) &#123; funA(b); //父类的引用可以用来接收子类对象 &#125;// 如下funD方法会报错public static void funC(List&lt;A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;) // ... &#125; 泛型并不具备“继承性”，比如：ArrayList&lt;Object&gt; obj = new ArrayList&lt;String&gt;();❎ ，例子中func接收的List的泛型A,而传入函数的参数是List&lt;B&gt;，虽然A与B有继承关系，但是泛型却不允许这样转换（为什么？可以留着这个问题，了解了泛型的原理之后再来思考）。这也是上个例子报错的原因。 但是程序确实需要这样的需求，比如在一个集合中添加某个类或者该类的实现类（举一个具体的例子，向一个List animal中添加元素，可以是猫，狗，鸟…继承了Animal的类的对象）。直接使用泛型就会存在问题。 为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。&lt;? extends A&gt;表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。 1234567public static void funC(List&lt;? extends A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // OK : funC接收的List的泛型类型是A及其子类 // ... &#125; 在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 上限： &lt;T extends Number&gt; 1234567891011121314151617class Info&lt;T extends Number&gt;&#123; // 此处泛型可以是Number或者继承了Number的类，比如Integer,Double... private T var ; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; return this.var.toString() ; &#125;&#125;public class demo1&#123; public static void main(String args[])&#123; Info&lt;Integer&gt; i1 = new Info&lt;Integer&gt;() ; // 声明Integer的泛型对象 &#125;&#125; 下限： &lt;? super String&gt; 12345678910111213141516171819202122232425class Info&lt;T&gt;&#123; private T var ; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; return this.var.toString() ; &#125;&#125;public class GenericsDemo21&#123; public static void main(String args[])&#123; Info&lt;String&gt; i1 = new Info&lt;String&gt;() ; // 声明String的泛型对象 Info&lt;Object&gt; i2 = new Info&lt;Object&gt;() ; // 声明Object的泛型对象 i1.setVar(&quot;hello&quot;) ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; &#125; public static void fun(Info&lt;? super String&gt; temp)&#123; // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + &quot;, &quot;) ; &#125;&#125; 如果对类型的上界或者下界有多个限制，可以使用 &amp; : 1234567891011public class Client &#123; //工资低于2500元的上斑族并且站立的乘客车票打8折 public static &lt;T extends Staff &amp; Passenger&gt; void discount(T t)&#123; if(t.getSalary()&lt;2500 &amp;&amp; t.isStanding())&#123; System.out.println(&quot;恭喜你！您的车票打八折！&quot;); &#125; &#125; public static void main(String[] args) &#123; discount(new Me()); &#125;&#125; 总结至此我们已经基本了解了在java中使用泛型的基本语法。接下来我们继续探究java泛型的实现原理以及使用的细节。 泛型的原理与使用细节java的伪泛型 ：类型擦除java的泛型策略实际上是一种伪泛型。即在语法上支持泛型，但在编译阶段会将所有的泛型（尖括号括起来的内容）都还原成原生态类型（Row Type）。比如List&lt;Integer&gt; list 在编译之后就变成：List list。这也是类型擦除（type erasure）的含义。 为什么要使用类型擦除来实现泛型呢？这样实现有什么好处？ 泛型机制是在jdk5引入的，为了兼容以前的版本，才采取了这种策略。这样使用新版的jdk写的程序编译之后与以前的代码是兼容的，就不需要重构旧的代码。 减轻 JVM 的负担，提高运行期的效率。如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作。 接下来我们来看几个具体的类型擦除的例子： 假设我们重载了这两个方法，编译器却报错： Erasure of method f1(List&lt;String&gt;) is the same as another method in type TypeEarse 即类型擦除后两个函数的签名是一致的，形参都变成 : List p1这是两个一样的函数。 1234567public class Test &#123; private void f1(List&lt;String&gt; p1) &#123; &#125; private void f1(List&lt;Integer&gt; p2) &#123; &#125;&#125; 再考虑一下下面的程序： 12345678910111213141516public class Test &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 程序中声明了一个存储Integer的ArrayList，直接调用add()方法只能存储整型变量。添加其他类型的元素： add(&quot;cjp&quot;)会报错 : The method add(Integer) in the type ArrayList&lt;Integer&gt; is not applicable for the arguments (String)。而我们如果使用反射就可以在运行过程中向集合中添加字符型类型的元素。这表明了在编译期间，ArrayList&lt;Integer&gt; list的类型是被擦除了的，还原成了原生类型：ArrayList，里面维护的Object数组，我们可以正常添加任何类型的元素。 那么类型擦除是如何进行的？ 参考文章：https://pdai.tech/md/java/basic/java-basic-x-generic.html 类型擦除的原则： 消除类型参数声明，即删除&lt;&gt;及其包围的部分。 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。 为了保证类型安全，必要时插入强制类型转换代码。 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。 例子： 擦除类定义中的类型参数 - 无限制类型擦除 当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如&lt;T&gt;和&lt;?&gt;的类型参数都被替换为Object。 擦除类定义中的类型参数 - 有限制类型擦除 当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如&lt;T extends Number&gt;和&lt;? extends Number&gt;的类型参数被替换为Number，&lt;? super Number&gt;被替换为Object。（Number的父类为Object） 擦除方法定义中的类型参数 擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。 泛型的编译期检查我们前面已经知道了泛型会在编译阶段被擦除成原生类型。那么为什么当我们往List&lt;Integer&gt; list这个集合中添加其它类型的元素的时候编译器会报错呢？编译期间不是都变成了Object了吗，我添加String为什么还会报错？ 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(123); list.add(&quot;123&quot;); //编译错误 &#125; 因为编译器会在编译之前先进行对泛型类型的检查，再进行类型擦除。那么这个检查是如何进行的呢？这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。 以 ArrayList举例子，以前的写法: 1ArrayList list = new ArrayList(); 现在的写法: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况： 12ArrayList&lt;String&gt; list1 = new ArrayList(); //第一种 情况ArrayList list2 = new ArrayList&lt;String&gt;(); //第二种 情况 这样是没有错误的，不过会有个编译时警 : ArrayList is a raw type. References to generic type ArrayList&lt;E&gt; should be parameterized。在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。 因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。 举例子： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list1 = new ArrayList(); list1.add(&quot;1&quot;); //编译通过 list1.add(1); //编译错误 String str1 = list1.get(0); //返回类型就是String ArrayList list2 = new ArrayList&lt;String&gt;(); list2.add(&quot;1&quot;); //编译通过 list2.add(1); //编译通过 Object object = list2.get(0); //返回类型就是Object new ArrayList&lt;String&gt;().add(&quot;11&quot;); //编译通过 new ArrayList&lt;String&gt;().add(22); //编译错误 String str2 = new ArrayList&lt;String&gt;().get(0); //返回类型就是String &#125; &#125; 通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。 泛型的多态与桥接方法泛型疑难杂症Ｑ＆A 在声明泛型类的对象时，不指定泛型编译也可以通过，这时候的对象中的相关成员类型是什么？ 泛型为什么没有继承的传递关系 泛型数组 静态成员与泛型","tags":["java-se"],"categories":["编程学习","java"]},{"title":"Hello World","path":"/2024/03/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"Welcome to my bolg!"}]